Adding a new checker to the cve-bin-tool
========================================

In order to add a new checker to the CVE-bin-tool, one must provide a checker
file.  See any checker in the `checkers/` directory as an example.

Currently, this checker must provide one function:

`get_version(lines, filename)`

The CVE-bin-checker works by extracting strings from binaries and determining
if a given library has been compiled into the binary.  This function takes as
input the extracted string lines and the filename and returns information about
whether the binary contains the library in question, is a copy of the library
in question, and if either of those are true it also returns a version string.
If the binary does not contain the library, this function returns an empty dict
structure.

The if the CLI for `curl` was scanned the output dict would look something like
this.

```json
{
  "is_or_contains": "is",
  "modulename": "curl",
  "version": "6.41.0"
}
```

The docstring of the function must contain the vendor and package name pair(s)
as they appear in NVD. The best way to do this is to search the cached sqlite
version of the NVD using a CVE you want to know the vendor package pair(s) for.

```console
$ sqlite3 ~/.cache/cvedb/cve.db \
    "SELECT vendor, product FROM cve_range WHERE CVE_Number='CVE-2016-0718';" \
    | sed -e 's/|/, /g' -e 's/^/VPkg\: /'
VPkg: apple, mac_os_x
VPkg: canonical, ubuntu_linux
VPkg: debian, debian_linux
VPkg: libexpat, expat
VPkg: mozilla, firefox
VPkg: opensuse, leap
VPkg: suse, linux_enterprise_debuginfo
```

The resulting docstring in `get_version` would have those `VPkg` listings at the
end of it. Some of the listings will be with regards to packages that include
this package. For our example all listings except `libexpat, expat` merely
include the target package (`expat` for the example SQL query).

```python
def get_version(lines, filename):
    '''
    Description...

    VPkg: libexpat, expat
    '''
```

Once the checker is added, its name should also be added to `__init__.py` (so
that `from modules import *` will find it).

## Hints for finding the right data to use

### Finding a version pattern

You can get a basic idea of the pattern from looking at the project's documentation/website or use cvedetails since it catalogs vulnerable versions and thus has version lists. Once you know what the version numbers look like, you'll need to find them in the code or the binary itself to make sure you've got a findable pattern.

A few ways to do it:

- The CVE Binary tool basically works by running the command line utility `strings` on a file, so if you have a local copy of the library, you can run `strings $libraryname` and see what comes out.  try `strings $libraryname | grep $version` and see what you find, and if you don't find it that way `strings $libraryname | less` and page through (maybe run a filter in there so it's only strings over a certain size?)

- If you don't have a copy, browse through the source to find the version string.  It's usually helpfully named something like 'version' so a quick grep/search often will turn it up, and if you know the latest version number (usually proudly mentioned in the latest news post or similar) you can grep for that and then look at the history to see what valid patterns look like.

### Avoiding false positives (beware the X.X.X version pattern!)

It can be very tempting to have a version pattern that matches `X.X.X` where `X` is a number  (or in regex form: `r"[0-9]+\.[0-9]+\.[0-9]+"`).  But beware! There are lots of other libraries potentially compiled in to your binary that will match `X.X.X`.  The one you're most likely going to see is glibc, the standard c library.

For an example, here's a list of some of the "interesting" version-like strings from one of our binary testfiles:

```
~/Code/cve-bin-tool$ strings test/binaries/test-png-unknown.out
/lib64/ld-linux-x86-64.so.2
libc.so.6
GLIBC_2.2.5
This program is designed to test the cve-bin-tool checker.
It outputs a few strings normally associated with png 1.6.36.
They appear below this line.
------------------
Application uses deprecated png_write_init() and should be recompiled
GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
printf@@GLIBC_2.2.5
__libc_start_main@@GLIBC_2.2.5
```

As you can see, there's a lot of things that will match `X.X.X`:

* glibc is version 2.2.5
* gcc is version 7.4.0
* Ubuntu is 18.04.1

So you want something that makes the version string a little more precise to the package you're looking for.  For example, if we were *intentionally* looking for glibc (as in, writing a glibc checker), we could use the string `GLIBC_` or `@@GLIBC_` as a prefix and get a regex that would tell us about glibc without also telling us the GCC and Ubuntu versions.

So a good regex signature for GLIBC might be `r"@@GLIBC_[0-9]+\.[0-9]+\.[0-9]+"`

The whole point of the CVE Binary Tool is to detect libraries that you might not know are there, so we'd expect it often to be used on binaries that have a lot of libraries compiled into them.  Finding a regex that detects only what you care about even in the face of a lot of similar strings is essential for us to avoid false positives.

It's also worth noting that sometimes there just aren't great version strings available: sometimes `X.X.X` is all you can find.  If you get stuck at this point, please make a note of it in the [New Checker](https://github.com/intel/cve-bin-tool/issues?utf8=%E2%9C%93&q=is%3Aissue+is%3Aopen+%22new+checker%22) issue if there is one. (You can make a new one and note it there if there isn't.)  That helps other contributors know that that particular checker is going to be hard to do.  Once you've done that, you can abandon the checker and find something easier to work on, or you can try to think outside the box to find another way to detect the version.  One example is how we did it for the [sqlite3 get_version_map() function](https://github.com/intel/cve-bin-tool/blob/master/cve_bin_tool/checkers/sqlite.py#L104) where the checker uses version hashes from the website that are *also* stored as strings in the binary.

### Choosing a signature to detect the library
You want a signature that hasn't changed in a large number of versions so you'll detect the library as long as possible (and if you notice that it did change before some version date, you can always add more strings to improve the coverage).  If you have a copy of the library you can run `strings $libraryname` to find some candidate strings that look good, then you should look at their source repository to see when those strings were added and if they were changed.  (there's a 'history' button on github for this, or other tools for other repositories).

## Adding tests
There are two types of tests you want to add to prove that your checker works as expected:

1. Test to show that the cve mapping works as expected.  
2. Tests to show that the checker correctly detects real binaries.

You can read about how to add these in [tests/README.md](https://github.com/intel/cve-bin-tool/blob/master/test/README.md)
