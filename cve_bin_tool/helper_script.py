# Copyright (C) 2021 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import re

from cve_bin_tool.cvedb import CVEDB, DBNAME, DISK_LOCATION_DEFAULT
from cve_bin_tool.error_handler import ErrorHandler, ErrorMode, UnknownArchiveType
from cve_bin_tool.extractor import Extractor
from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import DirWalk, inpath
from cve_bin_tool.version_scanner import VersionScanner # using it just for clean_file_path
from cve_bin_tool.strings import Strings


class HelperScript:
    """Helps Contributors to understand how various common filenames, version-strings, etc. look"""

    dbname = os.path.join(DISK_LOCATION_DEFAULT, DBNAME)

    def __init__(self, filename, vendor_name=None, product_name=None):
        self.filename = filename
        self.extractor = Extractor()
        self.logger = LOGGER.getChild(self.__class__.__name__)
        self.product = product_name or self.parse_filename(filename)
        self.vendor = vendor_name

        # for setting the data
        self.connection = None
        self.dbpath = os.path.join(DISK_LOCATION_DEFAULT, DBNAME)

        # for extraction
        self.walker = DirWalk().walk
        self.file_stack = []

        # for output
        self.contain_patterns = []
        self.filename_pattern =[]
        self.version_pattern = []
        self.vendor_product = []

    def extract_file(self):
        with self.extractor as ectx:
            if ectx.can_extract(self.filename):
                binary_string_list = []
                for filepath in self.walker([ectx.extract(self.filename)]):
                    clean_path = VersionScanner.clean_file_path(filepath) # to be removed???
                    self.file_stack.append(f"{clean_path}")
                    self.logger.info(f"scanning binaries from {clean_path}")
                    # go to that path and scan for strings
                    matches = self.search_pattern(self.parse_strings(filepath)) # list of strings in binary
                    binary_string_list.append(matches)
                return binary_string_list

    def parse_strings(self, filepath):
        s = Strings(filepath)
        lines = s.parse()
        return lines

    def search_pattern(self, string_list):
        pattern = r"" + self.product + r"(\d+.\d+.\d+)?"
        matched = [i.strip() for i in string_list if re.search(pattern, i, re.IGNORECASE)]
        return matched

    def parse_filename(self, filename):
        """
        returns package_name/product_name from package_filename of types .rpm, .deb, etc.
        Example: package_filename = openssh-client_8.4p1-5ubuntu1_amd64.deb
            here, package_name = openssh-client
        """

        filename = filename.split("/")[-1]  # for directory names
        if self.extractor.can_extract(filename):
            if filename.endswith(".tar.xz"):
                product_name = filename.rsplit("-", 3)[0]
                # example: libarchive-3.5.1-1-aarch64.pkg.tar.xz
            elif filename.endswith(".deb") or filename.endswith(".ipk"):
                product_name = filename.rsplit("_")[0]
            else:
                product_name = filename.rsplit("-", 2)[0]
            self.logger.debug(f"The product name is {product_name}")

            return product_name
        else:
            # self.logger.error("Unknown Archive Type")
            with ErrorHandler(mode=ErrorMode.NoTrace, logger=self.logger):
                raise UnknownArchiveType(filename)

    def find_vendor_product(self):
        # self.logger.debug(f"product_name='{self.product}'")

        CVEDB.db_open(self)
        cursor = self.connection.cursor()

        # finding out all distinct (vendor, product) pairs with the help of product_name
        query = f"""
            SELECT distinct vendor, product FROM cve_range
            WHERE product=(:product);
        """

        cursor.execute(query, {"product": self.product})
        data = cursor.fetchall()

        # checking if (vendor, product) was found in the database
        if data:
            if len(data) != 1:
                # finding out (vendor, product) pair, when vendor_name is given
                if self.vendor:
                    query = f"""
                        SELECT distinct vendor, product FROM cve_range
                        WHERE vendor=(:vendor) AND product=(:product);
                    """

                    cursor.execute(
                        query, {"vendor": self.vendor, "product": self.product}
                    )
                    data = cursor.fetchall()

                    # warning message when vendor_name is wrong (due to typo)
                    if not data:
                        self.logger.error(
                            f"'{self.product}' has no vendor with name '{self.vendor}'"
                        )

                # warning the user to specify vendor_name for accurate results
                else:
                    self.logger.warning(
                        f"""Multiple (vendor, product) pairs found.
                        \nPlease try specifying the "vendor_name" for accurate reseults.
                        """
                    )
            return data  # [('vendor', 'product')]
        else:
            if self.product:
                if any(char.isdigit() for char in self.product):
                    # self.logger.debug(f"removing digits from product_name.")
                    self.product = "".join(
                        filter(lambda x: not x.isdigit(), self.product)
                    )
                    return self.find_vendor_product()
                else:
                    self.logger.warning(
                        f"""No match was found for "{self.product}" in database. 
                        \nPlease check your file or try specifying the "product_name" also.
                        """
                    )
                    return []

        CVEDB.db_close(self)

    def output(self):
        pass

if __name__ == "__main__":
    filename = "busybox-1.33.1-1.fc35.x86_64.rpm"
    h = HelperScript(filename)
    e = h.extract_file()
    
    for i in h.file_stack:
        print(i)

    for i in range(len(e)):
        LOGGER.info(f"strings found in {h.file_stack[i]}")
        for j in e[i]:
            print(j)