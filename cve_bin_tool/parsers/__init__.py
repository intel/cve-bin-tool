# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import annotations

import re
import sqlite3
from pathlib import Path

from packageurl import PackageURL

from cve_bin_tool.error_handler import CVEDBError
from cve_bin_tool.util import ProductInfo, ScanInfo

__all__ = [
    "parse",
    "Parser",
    "java",
    "javascript",
    "python",
    "r",
    "ruby",
    "rust",
    "go",
    "swift",
    "php",
    "perl",
    "dart",
    "env",
]


class Parser:
    """
    A class to parse and process data related to known software components,
    typically generated for or by programming languages.

    Attributes:
        cve_db (CVE_DB): An instance of CVE_DB used for CVE database operations.
        logger (Logger): An instance of Logger used for logging.
        filename (str): The filename of the data to be processed.
    """

    def __init__(self, cve_db, logger):
        """Initializes a Parser object."""
        self.cve_db = cve_db
        self.logger = logger
        self.filename = ""
        self.purl_pkg_type = "default"

    def run_checker(self, filename):
        """
        Runs the checker for the specified filename.

        Args:
            filename (str): The filename to be checked.
        """
        pass

    def find_vendor(self, product, version):
        """
        Finds the vendor for the given product and version.

        Args:
            product (str): The product name.
            version (str): The product version.

        Returns:
            list: A list of ScanInfo objects containing vendor information.
        """
        vendor_package_pair = self.cve_db.get_vendor_product_pairs(product)
        vendorlist: list[ScanInfo] = []
        file_path = self.filename
        location = file_path
        if vendor_package_pair != []:
            # To handle multiple vendors, return all combinations of product/vendor mappings
            for v in vendor_package_pair:
                vendor = v["vendor"]
                location = v.get("location", self.filename)
                self.logger.debug(f"{file_path} {product} {version} by {vendor}")
                vendorlist.append(
                    ScanInfo(ProductInfo(vendor, product, version, location), file_path)
                )
        else:
            # Add entry
            vendorlist.append(
                ScanInfo(ProductInfo("UNKNOWN", product, version, location), file_path)
            )
        return vendorlist

    def generate_purl(self, product, vendor="", qualifier={}, subpath=None):
        """Generate purl string based on various components."""
        purl = PackageURL(
            type=self.purl_pkg_type,
            namespace=vendor,
            name=product,
            qualifiers=qualifier,
            subpath=subpath,
        )
        return purl

    def find_vendor_from_purl(self, purl, ver) -> tuple[list[ScanInfo], bool]:
        """
        Finds the vendor information for a given PackageURL (purl) and version from the database.

        This method queries the database to retrieve Common Platform Enumeration (CPE) data associated with the given purl.
        It then decodes the CPE data to extract vendor, product, and version information. If the version matches the provided
        version, it constructs a ScanInfo object for each matching entry and returns a list of these objects.
        """
        try:
            purl = purl.to_dict()
            param1 = f"pkg:{purl['type']}/{purl['name']}"
            param2 = f"pkg:{purl['type']}/%/{purl['name']}"

            query = """
                SELECT cpe from purl2cpe WHERE purl LIKE ?
                UNION
                SELECT cpe from purl2cpe WHERE purl LIKE ?
            """
            cursor = self.db_open_and_get_cursor()
            cursor.execute(query, (param1, param2))
            cpeList = cursor.fetchall()
            vendorlist: list[ScanInfo] = []
            vendors = set()

            if cpeList != []:
                for item in cpeList:
                    vendor, _, _ = self.decode_cpe23(str(item))
                    vendors.add((vendor, purl["name"]))
            else:
                return vendorlist, False

            purl_with_ver = f"{str(purl)}@{ver}"
            for vendor, product in vendors:
                vendorlist.append(
                    ScanInfo(
                        ProductInfo(
                            vendor,
                            product,
                            ver,
                            "/usr/local/bin/product",
                            purl_with_ver,
                        ),
                        self.filename,
                    )
                )

            return vendorlist, True
        except Exception as e:
            self.logger.error(f"Error occurred: {e}")
            return [], False

    def db_open_and_get_cursor(self) -> sqlite3.Cursor:
        """Opens connection to sqlite database, returns cursor object."""

        dbpath = (
            Path("~").expanduser() / ".cache" / "cve-bin-tool" / "purl2cpe/purl2cpe.db"
        )
        connection = sqlite3.connect(dbpath)

        if connection is not None:
            cursor = connection.cursor()
        if cursor is None:
            raise CVEDBError
        return cursor

    def decode_cpe23(self, cpe23) -> tuple[str, str, str]:
        """
        Decodes a CPE 2.3 formatted string to extract vendor, product, and version information.

        """

        # split on `:` only if it's not escaped
        cpe = re.split(r"(?<!\\):", cpe23)
        vendor, product, version = cpe[3], cpe[4], cpe[5]
        # Return available data, convert empty fields to None
        return (vendor, product, version)
