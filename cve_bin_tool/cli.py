#!/usr/bin/python3
# pylint: disable=invalid-name, useless-object-inheritance
# useless-object-inheritance kept for python2 compatibility

"""
This tool scans for a number of common, vulnerable open source components
(openssl, libpng, libxml2, expat and a few others) to let you know if your
system includes common libraries with known vulnerabilities.  It emits a list
of CVE numbers that may be relevant to your binary based on the versions.  It
cannot detect backported fixes.
"""

import argparse
import logging
import os
import platform
import sys
import textwrap

import pkg_resources

from cve_bin_tool.scanner import Scanner
from .OutputEngine import OutputEngine
from .cvedb import CVEDB, OLD_CACHE_DIR
from .log import LOGGER
from .version import VERSION


class LogAction(argparse.Action):
    """ Argparse action for selecting logging level."""

    def __call__(self, parser, namespace, value, option_string=None):
        """ Turns string into logging level definition."""
        setattr(namespace, self.dest, getattr(logging, value.upper(), logging.WARNING))


def main(argv=None):
    """ Scan a binary file for certain open source libraries that may have CVEs """
    if argv is None:
        argv = sys.argv

    # Reset logger level to info
    LOGGER.setLevel(logging.INFO)

    parser = argparse.ArgumentParser(
        prog="cve-bin-tool",
        description=textwrap.dedent(
            """
            The CVE Binary Tool scans for a number of common, vulnerable open source
            components (openssl, libpng, libxml2, expat and a few others) to let you know
            if a given directory or binary file includes common libraries with known
            vulnerabilities.
            """
        ),
        epilog=textwrap.fill(
            f'Available checkers: {", ".join(Scanner.available_checkers())}'
        )
        + "\n\nPlease disclose issues responsibly!",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("directory", help="directory to scan")

    output_group = parser.add_argument_group("Output")
    output_group.add_argument(
        "-q", "--quiet", action="store_true", help="suppress output"
    )
    output_group.add_argument(
        "-l",
        "--log",
        help="log level (default: info)",
        dest="log_level",
        action=LogAction,
        choices=["debug", "info", "warning", "error", "critical"],
    )
    output_group.add_argument(
        "-o",
        "--output-file",
        action="store",
        default=sys.stdout,
        help="provide output filename (default: output to stdout)",
    )
    output_group.add_argument(
        "-f",
        "--format",
        action="store",
        choices=["csv", "json", "console", "html"],
        default="console",
        help="update output format (default: console)",
    )
    parser.add_argument(
        "-V", "--version", action="version", version=VERSION,
    )
    parser.add_argument(
        "-u",
        "--update",
        action="store",
        choices=["now", "daily", "never", "latest"],
        default="daily",
        help="update schedule for NVD database (default: daily)",
    )
    # parser.add_argument(
    #     "-m", "--multithread", action="store_true", help="enable multithread"
    # )
    parser.add_argument(
        "-x", "--extract", action="store_true", help="autoextract compressed files"
    )

    checker_group = parser.add_argument_group("Checkers")
    checker_group.add_argument(
        "-s",
        "--skips",
        dest="skips",
        action="store",
        type=str,
        help="comma-separated list of checkers to disable",
    )
    checker_group.add_argument(
        "-r",
        "--runs",
        dest="checkers",
        action="store",
        type=str,
        help="comma-separated list of checkers to enable",
    )

    if len(argv) <= 1:
        parser.print_help()
        return 0

    try:
        args = parser.parse_args(argv[1:])
    except SystemExit:
        # override default argparse exit(2) behaviour so positive numbers can indicate
        sys.exit(-2)

    if args.log_level:
        LOGGER.setLevel(args.log_level)

    if args.quiet:
        LOGGER.setLevel(logging.CRITICAL)

    if platform.system() != "Linux":
        warning_nolinux = """
                          **********************************************
                          Warning: this utility was developed for Linux.
                          You may need to install additional utilities
                          to use it on other operating systems.
                          **********************************************
                          """
        LOGGER.warning(warning_nolinux)

    if not os.path.isfile(args.directory) and not os.path.isdir(args.directory):
        LOGGER.error("Error: directory/file invalid")
        parser.print_usage()
        return -1

    # Connect to the database
    cvedb_orig = CVEDB()

    # if OLD_CACHE_DIR (from cvedb.py) exists, print warning
    if os.path.exists(OLD_CACHE_DIR):
        LOGGER.warning(
            f"Obsolete cache dir {OLD_CACHE_DIR} is no longer needed and can be removed."
        )

    # Clear data if -u now is set
    if args.update == "now":
        cvedb_orig.clear_cached_data()

    if args.update == "latest":
        cvedb_orig.refresh_cache_and_update_db()

    # update db if needed
    if args.update != "never":
        cvedb_orig.get_cvelist_if_stale()

    skips = ""
    if args.skips:
        skips = args.skips

    if args.checkers:
        checkers = args.checkers.split(",")
        skips = ",".join(
            map(
                lambda checker: checker.name,
                filter(
                    lambda checker: checker.name not in checkers,
                    pkg_resources.iter_entry_points("cve_bin_tool.checker"),
                ),
            )
        )

    # Single-thread mode
    # if not args.multithread:

    # Close database when done
    cvedb = CVEDB()
    cvedb.open()
    with cvedb:
        scanner = Scanner(cvedb, args.extract)
        scanner.remove_skiplist(skips)
        LOGGER.info(scanner.print_checkers())
        scanner.recursive_scan(args.directory)

        LOGGER.info("")
        LOGGER.info("Overall CVE summary: ")
        LOGGER.info(
            f"There are {scanner.files_with_cve} files with known CVEs detected"
        )
        if scanner.files_with_cve > 0:
            affected_string = ", ".join(
                map(
                    lambda module_version: "".join(str(module_version)),
                    scanner.affected(),
                )
            )
            LOGGER.info(f"Known CVEs in {affected_string}:")

            # Creates a Object for OutputEngine
            output = OutputEngine(
                modules=scanner.all_cves, filename=args.output_file
            )

            if not args.quiet or args.output_file != sys.stdout:
                output.output_file(args.format)

        # Use the number of files with known cves as error code
        # as requested by folk planning to automate use of this script.
        # If no files found, then the program exits cleanly.
        return scanner.files_with_cve


if __name__ == "__main__":
    sys.exit(main())
