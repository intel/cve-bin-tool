# pylint: disable=too-many-arguments
""" Utility classes for the CVE Binary Tool """
import asyncio
import fnmatch
import glob
import os
import shutil
import sys
import tempfile
from functools import partial, wraps


def async_wrap(func):
    @wraps(func)
    async def run(*args, loop=None, executor=None, **kwargs):
        if loop is None:
            loop = asyncio.get_event_loop()
        pfunc = partial(func, *args, **kwargs)
        return await loop.run_in_executor(executor, pfunc)

    return run


async def run_command(args):
    print(f"running command: {' '.join(args)}...")
    process = await asyncio.create_subprocess_shell(
        *args, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await process.communicate()
    print(f"command: {' '.join(args)} completed successfully")
    return stdout.decode().strip(), stderr.decode().strip()


def regex_find(lines, version_patterns):
    """Search a set of lines to find a match for the given regex
    """
    new_guess = ""

    for line in lines:
        for pattern in version_patterns:
            match = pattern.search(line)
            if match:
                new_guess2 = match.group(1).strip()
                if len(new_guess2) > len(new_guess):
                    new_guess = new_guess2
    if new_guess != "":
        new_guess = new_guess.replace("_", ".")
        return new_guess.replace("-", ".")
    else:
        return "UNKNOWN"


def inpath(binary):
    """ Check to see if something is available in the path.
    Used to check if dependencies are installed before use. """
    if sys.platform == "win32":
        return any(
            list(
                map(
                    lambda dirname: os.path.isfile(
                        os.path.join(dirname, binary + ".exe")
                    ),
                    os.environ.get("PATH", "").split(";"),
                )
            )
        )
    return any(
        list(
            map(
                lambda dirname: os.path.isfile(os.path.join(dirname, binary)),
                os.environ.get("PATH", "").split(":"),
            )
        )
    )


class DirWalk:
    """
    for filename in DirWalk('*.c').walk(roots):
        do a thing with the c-files in the roots directories
    """

    def __init__(
        self,
        pattern="*",
        folder_include_pattern="*",
        folder_exclude_pattern=".git",
        file_exclude_pattern="",
        yield_files=True,
        yield_folders=False,
    ):
        """
        Generator for walking the file system and filtering the results.
        """
        self.pattern = pattern
        self.folder_include_pattern = folder_include_pattern
        self.folder_exclude_pattern = folder_exclude_pattern
        self.file_exclude_pattern = file_exclude_pattern
        self.yield_files = yield_files
        self.yield_folders = yield_folders

    def walk(self, roots=None):
        """ Walk the directory looking for files matching the pattern """
        if roots is None:
            roots = []
        for root in roots:
            for dirpath, dirnames, filenames in os.walk(root):
                # Filters
                filenames[:] = [
                    i
                    for i in filenames
                    if self.pattern_match(i, self.pattern)
                    and not self.pattern_match(i, self.file_exclude_pattern)
                ]
                dirnames[:] = [
                    i
                    for i in dirnames
                    if self.pattern_match(i, self.folder_include_pattern)
                    and not self.pattern_match(i, self.folder_exclude_pattern)
                ]
                # Yields
                if self.yield_files:
                    for filename in filenames:
                        yield os.path.normpath(os.path.join(dirpath, filename))
                if self.yield_folders:
                    for dirname in dirnames:
                        yield os.path.normpath(os.path.join(dirpath, dirname))

    @staticmethod
    def pattern_match(text, patterns):
        """ Match filename patterns """
        if not patterns:
            return False
        for pattern in patterns.split(";"):
            if fnmatch.fnmatch(text, pattern):
                return True
        return False


aio_rmdir = async_wrap(shutil.rmtree)
aio_rmfile = async_wrap(os.remove)
aio_unpack_archive = async_wrap(shutil.unpack_archive)
aio_glob = async_wrap(glob.glob)
aio_mkdtemp = async_wrap(tempfile.mkdtemp)
aio_makedirs = async_wrap(os.makedirs)
aio_inpath = async_wrap(inpath)