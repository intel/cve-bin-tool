import csv
import json
import os
import sys
import textwrap
import webbrowser

from datetime import datetime
from jinja2 import Environment, FileSystemLoader
import plotly.graph_objects as go

from .log import LOGGER


class OutputEngine(object):
    # Max space for each console tabular cell
    PRODUCTNAME_MAX = 18
    VERSION_MAX = 9
    CVE_NUMBER_MAX = 18
    CVE_SEVERITY_MAX = 9
    DOTS = "..."

    def __init__(
        self,
        products=None,
        filename=None,
        logger=None,
        files_with_cve=0,
        files_without_cve=0,
        total_files=0,
    ):
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        self.products = products
        self.filename = filename
        self.logger = logger
        self.files_with_cve = files_with_cve
        self.files_without_cve = files_without_cve
        self.total_files = total_files

        self.formatted_output = self.format_output()

    def generate_filename(self, extension=None):
        """ Generates a random filename"""
        if extension:
            now = datetime.now().strftime("%Y-%m-%d.%H-%M-%S")
            self.filename = f"output.cve-bin-tool.{now}.{extension}"

    def output_cves(self, outfile, output_type=None):
        """ Output a list of CVEs
        format self.modules[checker_name][version] = dict{id: severity}
        to other formats like CSV or JSON
        """
        if output_type == "json":
            self.output_json(outfile)
        elif output_type == "csv":
            self.output_csv(outfile)
        elif output_type == "html":
            self.output_html(outfile)
        else:  # console, or anything else that is unrecognised
            self.output_console(outfile)

    def format_output(self):
        """
        summary: format output in the list of dictionary format.

        Returns:
            type: list(dict) -- example: [{ "product": "curl",
                                            "version": "1.2.1",
                                            "cve_number": "CVE-1234-1234",
                                            "severity": "LOW"},
                                            ...]
        """
        formatted_output = []
        for product in self.products:
            for cve in product.cves:
                formatted_output.append(
                    {
                        "product": product.product,
                        "version": product.version,
                        "cve_number": cve.cve_id,
                        "severity": cve.severity,
                    }
                )
        return formatted_output

    def output_json(self, outfile):
        """ Output a JSON of CVEs """
        json.dump(self.formatted_output, outfile, indent="    ")

    def output_csv(self, outfile):
        """ Output a CSV of CVEs """
        writer = csv.DictWriter(
            outfile, fieldnames=["product", "version", "cve_number", "severity"]
        )
        writer.writeheader()
        writer.writerows(self.formatted_output)

    def write_console(self, productname, version, cve_number, cve_severity, outfile):
        """ Output Module, Version, CVE_Number, Severity to the console in tabular form"""

        if len(productname) > (self.PRODUCTNAME_MAX - len(self.DOTS)):
            productname = (
                productname[: self.PRODUCTNAME_MAX - len(self.DOTS)] + self.DOTS
            )
        if len(version) > (self.VERSION_MAX - len(self.DOTS)):
            version = version[: self.VERSION_MAX - len(self.DOTS)] + self.DOTS
        # Calculate length of -- productname, version, cve_number, cve_severity
        productname_len = len(productname)
        version_len = len(str(version))
        cve_number_len = len(cve_number)
        cve_severity_len = len(cve_severity)

        # Generate all the fields with appropriate space to be fit into tabular form
        productname = f"{productname}{' ' * (self.PRODUCTNAME_MAX - productname_len)}"
        version = f"{version}{' ' * (self.VERSION_MAX - version_len)}"
        cve_number = f"{cve_number}{' ' * (self.CVE_NUMBER_MAX - cve_number_len)}"
        cve_severity = (
            f"{cve_severity}{' ' * (self.CVE_SEVERITY_MAX - cve_severity_len)}"
        )

        # End string marks end for the previous length data
        end_string = f"+{'-' * (self.PRODUCTNAME_MAX + 2)}+{'-' * (self.VERSION_MAX + 2)}+{'-' * (self.CVE_NUMBER_MAX + 2)}+{'-' * (self.CVE_SEVERITY_MAX + 2)}+\n"

        # string generate the details in tabular form
        string = f"| {productname} | {version} | {cve_number} | {cve_severity} |\n"

        # Write String and End String to the console
        outfile.write(string)
        outfile.write(end_string)

    def output_console(self, outfile):
        """ Output list of CVEs in a tabular format  """

        # Now contains the time at which report is generated
        now = datetime.now().strftime("%Y-%m-%d  %H:%M:%S")

        # The main heading containing CVE-Bin-Tool logo
        # textwrap.dedent removes any extra white space for each line.
        heading = textwrap.dedent(
            f"""
            +=================================================================+
            |   ___ _    __ ____    ___  ___  _   _    _____  ___  ___  _     |
            |  / __| \  / /| ___]  |   )[   ]| \ | |  [_   _]| _ || _ || |    |
            | | |__ \ \/ / | _]_ = | <   | | | |\| | =  | |  ||_||||_||| |__  |
            |  \___| \__/  |___ ]  |___)[___]|_| \_|    |_|  |___||___||____| |
            |                                                                 |
            +=================================================================+
            |   CVE Binary Tool Report Generated: {now}        |
            +=================================================================+

            +=================================================================+
            |   PRODUCT NAME     |  VERSION  |    CVE NUMBER      | SEVERITY  |
            +=================================================================+
            """
        )

        # Outputs Heading to the console
        outfile.write(heading)

        # for every product that is scanned -- output to the console
        for output in self.formatted_output:
            # call to the write_console function for each product,version
            self.write_console(
                output["product"],
                output["version"],
                output["cve_number"],
                output["severity"],
                outfile,
            )

    def output_file(self, output_type="csv"):

        """ Generate a file for list of CVE """
        if self.filename == sys.stdout:
            # short circuit file opening logic if we are actually
            # just writing to stdout
            self.output_cves(self.filename, output_type)
            return

        # Check if we need to generate a filename
        if self.filename is None:
            self.generate_filename(output_type)
        else:
            # check if the filename already exists
            file_list = os.listdir(os.getcwd())
            if self.filename in file_list:
                self.logger.warning(
                    f"Failed to write at '{self.filename}'. File already exists"
                )
                self.logger.info(
                    "Generating a new filename with Default Naming Convention"
                )
                self.generate_filename(output_type)

            # try opening that file
            try:
                with open(self.filename, "w") as f:
                    f.write("testing")
                os.remove(self.filename)
            except Exception as E:
                self.logger.warning(E)
                self.logger.info("Switching Back to Default Naming Convention")
                self.generate_filename(output_type)

        # Log the filename generated
        self.logger.info(f"Output stored at {os.getcwd()}/{self.filename}")

        # call to output_cves
        with open(self.filename, "w") as f:
            self.output_cves(f, output_type)

    def output_html(self, outfile):
        """Returns a HTML report for CVE's
        """

        # Step 1: Load all the templates

        # Root folder where html_reports is present
        root = os.path.dirname(os.path.abspath(__file__))

        # Template Directory contains all the html files
        templates_dir = os.path.join(root, "html_reports", "templates")
        templates_env = Environment(loader=FileSystemLoader(templates_dir))
        base = templates_env.get_template("base.html")
        dashboard = templates_env.get_template("dashboard.html")
        cve_row = templates_env.get_template("row_cve.html")
        product_row = templates_env.get_template("row_product.html")

        # Step 2: Prepare Charts
        # Start generating graph with the data

        # dash graph1: Products Vulnerability Graph
        product_pie = go.Figure(
            data=[
                go.Pie(
                    labels=["Vulnerable", "No Known Vulnerability"],
                    values=[self.files_with_cve, self.files_without_cve],
                    hole=0.4,
                )
            ]
        )

        # Chart configuration for product_pie
        product_pie.update_layout(
            autosize=True, legend_orientation="h",
        )

        # dash graph2: Product CVE's Graph
        cve_bar = go.Figure()
        for product in self.products:
            if product.cves:
                cve_bar.add_trace(
                    go.Bar(
                        x=[f"{product.product}-{product.version}"],
                        y=[len(product.cves)],
                        name=f"{product.product[:7]}",
                    )
                )

        # Chart configuration for cve_bar
        cve_bar.update_layout(yaxis_title="Number of CVE's",)

        products_found = ""
        # List of Products
        for product in self.products:
            # Check if product contains CVEs
            if product.cves:

                # List cves contains template version of all the cves
                list_cves = ""

                # hid will be used as id by HTML report to remove collisions
                hid = f"{product.product}{''.join(product.version.split('.'))}"

                analysis_data = {"critical": 0, "high": 0, "medium": 0, "low": 0}
                for i, cve in enumerate(product.cves):
                    # render CVE template with data and add to list_cves
                    list_cves += cve_row.render(
                        cve_number=cve.cve_id,
                        severity=cve.severity,
                        description=cve.description,
                        var_id=f"{hid}{i}",
                        fix_id=hid,
                    )

                    # generate analysis_data
                    if cve.severity.lower() == "critical":
                        analysis_data["critical"] += 1
                    elif cve.severity.lower() == "high":
                        analysis_data["high"] += 1
                    elif cve.severity.lower() == "medium":
                        analysis_data["medium"] += 1
                    elif cve.severity.lower() == "low":
                        analysis_data["low"] += 1
                    else:
                        pass

                # initialize a figure object for Analysis Chart
                analysis_pie = go.Figure(
                    data=[
                        go.Pie(
                            labels=["Critical", "High", "Medium", "Low"],
                            values=[
                                analysis_data["critical"],
                                analysis_data["high"],
                                analysis_data["medium"],
                                analysis_data["low"],
                            ],
                            hole=0.4,
                        )
                    ]
                )
                analysis_pie.update_traces(
                    hoverinfo="label+percent",
                    textinfo="value",
                    textfont_size=14,
                    marker=dict(
                        colors=["#f25f5c", "#ee6c4d", "#f4d35e", "#90a955"],
                        line=dict(color="white", width=2),
                    ),
                )
                analysis_pie.update_layout(
                    autosize=True,
                    height=300,
                    legend_orientation="h",
                    margin=dict(l=0, r=20, t=0, b=0),
                    # paper_bgcolor="LightSteelBlue",
                )

                products_found += product_row.render(
                    vendor=product.vendor,
                    name=product.product,
                    version=product.version,
                    cve_count=len(product.cves),
                    list_cves=list_cves,
                    severity_analysis=analysis_pie.to_html(
                        full_html=False, include_plotlyjs=False
                    ),
                    fix_id=hid,
                )

        # Dashboard Rendering
        dashboard = dashboard.render(
            graph_cves=cve_bar.to_html(full_html=False, include_plotlyjs=False),
            graph_products=product_pie.to_html(full_html=False, include_plotlyjs=False),
            total_files=self.total_files,
            files_with_cve=self.files_with_cve,
        )

        # try to load the bigger files just before the generation of report

        # Style directory conatains all the CSS files
        styles_dir = os.path.join(root, "html_reports", "css")
        styles_env = Environment(loader=FileSystemLoader(styles_dir))
        style_main = styles_env.get_template("main.css")
        style_bootstrap = styles_env.get_template("bootstrap.min.css")

        # Script directory will contain all the JS files
        scripts_dir = os.path.join(root, "html_reports", "js")
        scripts_env = Environment(loader=FileSystemLoader(scripts_dir))
        script_main = scripts_env.get_template("main.js")
        script_bootstrap = scripts_env.get_template("bootstrap.min.js")
        script_plotly = scripts_env.get_template("plotly-latest.min.js")
        script_jquery = scripts_env.get_template("jquery-3.4.1.slim.min.js")

        # Render the base html to generate report
        outfile.write(
            base.render(
                date=datetime.now().strftime("%d %b %Y"),
                dashboard=dashboard,
                products_found=products_found,
                style_main=style_main.render(),
                style_bootstrap=style_bootstrap.render(),
                script_main=script_main.render(),
                script_jquery=script_jquery.render(),
                script_bootstrap=script_bootstrap.render(),
                script_plotly=script_plotly.render(),
            )
        )

        self.logger.info(f"Report is stored at location {os.getcwd()}/{self.filename}")
        self.logger.info("Opening Report in Browser. Please Wait...")
        try:
            webbrowser.open(self.filename)
        except Exception:
            self.logger.warning("Can't Open in Browser")
