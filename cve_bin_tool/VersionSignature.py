import os
import sqlite3
import datetime

DISK_LOCATION_DEFAULT = os.path.join(os.path.expanduser("~"), ".cache", "cve-bin-tool")


class VersionSignatureDb:
    """ Methods for version signature data stored in sqlite """

    def __init__(self, table_name, mapping_function, duration):
        """ Set location on disk data cache will reside.
            Also sets the table name and refresh duration
        """
        self.table_name = table_name
        self.mapping_function = mapping_function
        self.disk_location = DISK_LOCATION_DEFAULT
        self.duration = duration
        self.conn = None
        self.cursor = None

    @property
    def dbname(self):
        """ SQLite datebase file where the data is stored."""
        return os.path.join(self.disk_location, "version_map.db")

    def open(self):
        """ Opens connection to sqlite database."""
        self.conn = sqlite3.connect(self.dbname)
        self.cursor = self.conn.cursor()

    def close(self):
        """ Closes connection to sqlite database."""
        self.cursor.close()
        self.conn.close()
        self.conn = None
        self.cursor = None

    def __enter__(self):
        """ Opens connection to sqlite database."""
        self.open()

    def __exit__(self, exc_type, exc_val, exc_tb):
        """ Closes connection to sqlite database."""
        self.close()

    def get_mapping_data(self):
        """
        Returns a version map associated with the specified checker. Also takes care of updating
        the data after the specified refresh duration
        """
        self.cursor.execute(
            "CREATE TABLE IF NOT EXISTS {}(version TEXT , sourceId TEXT PRIMARY KEY)".format(
                self.table_name
            )
        )
        # fetch first entry
        entry = self.cursor.execute(
            "SELECT * FROM {}".format(self.table_name)
        ).fetchone()
        update_required = False
        if entry is not None:
            # Check if update is required
            # Updates if the difference between current time and the time of latest release is greater than duration
            cur_time = datetime.datetime.now().replace(microsecond=0)
            time_fields = entry[1].split()
            year_data = time_fields[0].split("-")
            time_data = time_fields[1].split(":")
            yy, mm, dd = int(year_data[0]), int(year_data[1]), int(year_data[2])
            H, M, S = int(time_data[0]), int(time_data[1]), int(time_data[2])
            last_release = datetime.datetime(yy, mm, dd, H, M, S)
            time_elapsed = str(cur_time - last_release)
            if int(time_elapsed.split()[0]) >= self.duration:
                update_required = True

        if entry is None or update_required:
            # if update is required or database is empty, fetch and insert data into database
            self.cursor.execute("DELETE FROM {}".format(self.table_name))
            for mapping in self.mapping_function():
                self.cursor.execute(
                    "INSERT INTO {} (version, sourceId) VALUES (?, ?)".format(
                        self.table_name
                    ),
                    (mapping[0], mapping[1]),
                )

        data = self.cursor.execute(
            "SELECT * FROM {}".format(self.table_name)
        ).fetchall()
        self.conn.commit()
        return data
