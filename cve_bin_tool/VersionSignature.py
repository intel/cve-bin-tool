import os
import sqlite3
from datetime import date, datetime

DISK_LOCATION_DEFAULT = os.path.join(os.path.expanduser("~"), ".cache", "cve-bin-tool")


class VersionSignatureDb:
    """ Methods for version signature data stored in sqlite """

    def __init__(self, table_name, mapping_function, duration):
        """ Set location on disk data cache will reside.
            Also sets the table name and refresh duration
        """
        self.table_name = table_name
        self.mapping_function = mapping_function
        self.disk_location = DISK_LOCATION_DEFAULT
        self.duration = duration
        self.conn = None
        self.cursor = None

    @property
    def dbname(self):
        """ SQLite datebase file where the data is stored."""
        return os.path.join(self.disk_location, "version_map.db")

    def open(self):
        """ Opens connection to sqlite database."""
        self.conn = sqlite3.connect(self.dbname)
        self.cursor = self.conn.cursor()

    def close(self):
        """ Closes connection to sqlite database."""
        self.cursor.close()
        self.conn.close()
        self.conn = None
        self.cursor = None

    def __enter__(self):
        """ Opens connection to sqlite database."""
        self.open()

    def __exit__(self, exc_type, exc_val, exc_tb):
        """ Closes connection to sqlite database."""
        self.close()

    def get_mapping_data(self):
        """
        Returns a version map associated with the specified checker. Also takes care of updating
        the data after the specified refresh duration
        """
        self.cursor.execute(
            "CREATE TABLE IF NOT EXISTS {}(version TEXT , sourceId TEXT PRIMARY KEY)".format(
                self.table_name
            )
        )

        self.cursor.execute(
            "CREATE TABLE IF NOT EXISTS {} (date TEXT PRIMARY KEY)".format(
                "last_update_" + self.table_name
            )
        )

        update_required = False

        datestring = self.cursor.execute(
            "SELECT * FROM {}".format("last_update_" + self.table_name)
        ).fetchone()

        if datestring is not None:
            # Updates if the difference between current time and the time of last update is greater than duration

            update_date = datetime.strptime(datestring[0], "%Y-%m-%d")
            last_update = date(update_date.year, update_date.month, update_date.day)
            cur_time = date.today()
            time_elapsed = cur_time - last_update
            if time_elapsed.days >= self.duration:
                update_required = True

        if datestring is None or update_required:
            # if update is required or database is empty, fetch and insert data into database
            self.cursor.execute("DELETE FROM {}".format(self.table_name))

            self.cursor.execute(
                "DELETE FROM {}".format("last_update_" + self.table_name)
            )
            self.cursor.execute(
                "INSERT INTO {} VALUES (?)".format("last_update_" + self.table_name),
                (date.today(),),
            )

            for mapping in self.mapping_function():
                self.cursor.execute(
                    "INSERT INTO {} (version, sourceId) VALUES (?, ?)".format(
                        self.table_name
                    ),
                    (mapping[0], mapping[1]),
                )

        data = self.cursor.execute(
            "SELECT * FROM {}".format(self.table_name)
        ).fetchall()
        self.conn.commit()
        return data
