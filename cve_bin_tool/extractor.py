# pylint: disable=useless-object-inheritance, keyword-arg-before-vararg
# disabled for python2 compatibility reasons
"""
Extraction of archives
"""
import asyncio
import itertools
import os
import shutil
import sys
import tempfile

from .log import LOGGER
from .async_utils import (
    aio_unpack_archive,
    aio_run_command,
    aio_glob,
    aio_inpath,
    aio_rmdir,
    aio_makedirs,
    aio_mkdtemp,
    ChangeDirContext,
    FileIO,
)


class ExtractionFailed(ValueError):
    """ Extraction fail """


class UnknownArchiveType(ValueError):
    """ Unknown archive type"""


class BaseExtractor(object):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, logger=None):
        """Sets up logger and if we should extract files or just report"""
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        self.logger = logger
        self.file_extractors = {
            self.extract_file_tar: {".tgz", ".tar.gz", ".tar", ".tar.xz", ".tar.bz2"},
            self.extract_file_rpm: {".rpm"},
            self.extract_file_deb: {".deb", ".ipk"},
            self.extract_file_cab: {".cab"},
            self.extract_file_zip: {".exe", ".zip", ".jar", ".apk", ".msi"},
        }

    def can_extract(self, filename):
        """ Check if the filename is something we know how to extract """
        for extension in itertools.chain(*self.file_extractors.values()):
            if filename.endswith(extension):
                return True
        return False

    @classmethod
    async def extract_file_tar(cls, filename, extraction_path):
        """ Extract tar files """
        try:
            await aio_unpack_archive(filename, extraction_path)
            return 0
        except Exception:
            return 1

    @classmethod
    async def extract_file_rpm(cls, filename, extraction_path):
        """ Extract rpm packages """
        if sys.platform.startswith("linux"):
            if not await aio_inpath("rpm2cpio") or not await aio_inpath("cpio"):
                raise Exception(
                    "'rpm2cpio' and 'cpio' are required to extract rpm files"
                )
            else:
                stdout, stderr = await aio_run_command(["rpm2cpio", filename])
                if stderr or not stdout:
                    return 1
                cpio_path = os.path.join(extraction_path, "data.cpio")
                async with FileIO(cpio_path, "wb") as f:
                    await f.write(stdout)
                stdout, stderr = await aio_run_command(
                    ["cpio", "-idm", "--file", cpio_path]
                )
                if stdout or not stderr:
                    return 1
        else:
            if not await aio_inpath("7z"):
                raise Exception("7z is required to extract rpm files")
            else:
                stdout, stderr = await aio_run_command(["7z", "x", filename])
                if stderr or not stdout:
                    return 1
                filenames = await aio_glob(os.path.join(extraction_path, "*.cpio"))
                filename = filenames[0]

                stdout, stderr = await aio_run_command(["7z", "x", filename])
                if stderr or not stdout:
                    return 1
        return 0

    @classmethod
    async def extract_file_deb(cls, filename, extraction_path):
        """ Extract debian packages """
        if not await aio_inpath("ar"):
            raise Exception("'ar' is required to extract deb files")
        else:
            stdout, stderr = await aio_run_command(["ar", "x", filename])
            if stderr:
                return 1
            datafile = await aio_glob(os.path.join(extraction_path, "data.tar.*"))
            try:
                await aio_unpack_archive(datafile[0], extraction_path)
            except Exception:
                return 1
            return 0

    @classmethod
    async def extract_file_cab(cls, filename, extraction_path):
        """ Extract cab files """
        if sys.platform.startswith("linux"):
            if not await aio_inpath("cabextract"):
                raise Exception("'cabextract' is required to extract cab files")
            else:
                stdout, stderr = await aio_run_command(
                    ["cabextract", "-d", extraction_path, filename]
                )
                if stderr or not stdout:
                    return 1
        else:
            stdout, stderr = await aio_run_command(
                ["Expand", filename, "-F:*", extraction_path]
            )
            if stderr or not stdout:
                return 1
        return 0

    @classmethod
    async def extract_file_zip(cls, filename, extraction_path):
        """ Extract zip files """
        if await aio_inpath("unzip"):
            stdout, stderr = await aio_run_command(
                ["unzip", "-n", "-d", extraction_path, filename]
            )
            if stderr or not stdout:
                return 1
        elif await aio_inpath("7z"):
            stdout, stderr = await aio_run_command(["7z", "x", filename])
            if stderr or not stdout:
                return 1
        else:
            try:
                await aio_unpack_archive(filename, extraction_path)
            except Exception:
                return 1
        return 0


class TempDirExtractorContext(BaseExtractor):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, raise_failure=False, *args, **kwargs):
        BaseExtractor.__init__(self, *args, **kwargs)
        self.tempdir = None
        self.raise_failure = raise_failure

    async def aio_extract(self, filename):
        """ Run the extractor """
        # Resolve path in case of cwd change
        filename = os.path.abspath(filename)
        for extractor in self.file_extractors:
            for extension in self.file_extractors[extractor]:
                if filename.endswith(extension):
                    extracted_path = os.path.join(
                        self.tempdir, f"{os.path.basename(filename)}.extracted"
                    )
                    if os.path.exists(extracted_path):
                        await aio_rmdir(extracted_path)
                    await aio_makedirs(extracted_path, 0o700)
                    async with ChangeDirContext(extracted_path):
                        if await extractor(filename, extracted_path) != 0:
                            if self.raise_failure:
                                raise ExtractionFailed(filename)
                            else:
                                self.logger.warning(f"Failure extracting {filename}")
                        else:
                            self.logger.debug(
                                f"Extracted {filename} to {extracted_path}"
                            )
                    return extracted_path
        raise UnknownArchiveType(filename)

    async def __aenter__(self):
        """ Create a temporary directory to extract files to. """
        self.tempdir = await aio_mkdtemp(prefix="cve-bin-tool-")
        return self

    async def __aexit__(self, exc_type, exc, exc_tb):
        """ Removes all extraction directories that need to be cleaned up."""
        await aio_rmdir(self.tempdir)

    def extract(self, filename):
        aws = asyncio.ensure_future(self.aio_extract(filename))
        result = self.loop.run_until_complete(aws)
        return result

    def __enter__(self):
        self.tempdir = tempfile.mkdtemp(prefix="cve-bin-tool-")
        self.loop = asyncio.get_event_loop()
        if sys.platform.startswith("win"):
            if isinstance(self.loop, asyncio.SelectorEventLoop):
                self.loop = asyncio.ProactorEventLoop()
                asyncio.set_event_loop(self.loop)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        shutil.rmtree(self.tempdir)


class Extractor(BaseExtractor):
    """Provides a context which extraction is done in"""

    def __call__(self, *args, **kwargs):
        return TempDirExtractorContext(*args, **kwargs)
