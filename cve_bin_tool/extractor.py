# pylint: disable=useless-object-inheritance, keyword-arg-before-vararg
# disabled for python2 compatibility reasons
"""
Extraction of archives
"""
import itertools
import os
import sys

from .log import LOGGER
from .util import aio_unpack_archive, run_command, aio_glob, aio_rmfile, aio_inpath, aio_rmdir, \
    aio_makedirs, aio_mkdtemp


class ExtractionFailed(ValueError):
    """ Extraction fail """


class UnknownArchiveType(ValueError):
    """ Unknown archive type"""


class BaseExtractor(object):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, logger=None):
        """Sets up logger and if we should extract files or just report"""
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        self.logger = logger
        self.file_extractors = {
            self.extract_file_tar: {".tgz", ".tar.gz", ".tar", ".tar.xz", ".tar.bz2"},
            self.extract_file_rpm: {".rpm"},
            self.extract_file_deb: {".deb", ".ipk"},
            self.extract_file_cab: {".cab"},
            self.extract_file_zip: {".exe", ".zip", ".jar", ".apk", ".msi"},
        }

    def can_extract(self, filename):
        """ Check if the filename is something we know how to extract """
        for extention in itertools.chain(*self.file_extractors.values()):
            if filename.endswith(extention):
                return True
        return False

    @classmethod
    async def extract_file_tar(cls, filename, extraction_path):
        """ Extract tar files """
        try:
            await aio_unpack_archive(filename, extraction_path)
            return 0
        except Exception:
            return 1

    @classmethod
    async def extract_file_rpm(cls, filename, extraction_path):
        """ Extract rpm packages """
        if sys.platform.startswith("linux"):
            if not await aio_inpath("rpm2cpio") or not await aio_inpath("cpio"):
                raise Exception(
                    "'rpm2cpio' and 'cpio' are required to extract rpm files"
                )
            else:
                current_dir = os.path.abspath(os.curdir)
                os.chdir(extraction_path)
                print(filename)
                await run_command(["rpm2cpio", filename, "|", "cpio", "-idm"])
                print(os.listdir(extraction_path))
                # filenames = await aio_glob(extraction_path + "\\" + "*.cpio")
                # filename = filenames[0]
                # await run_command(["cpio", "-idm", "--quiet", filename])
                os.chdir(current_dir)
        else:
            if not await aio_inpath("7z"):
                raise Exception("7z is required to extract rpm files")
            else:
                cpio_path = filename.split("\\")
                cpio_path = "\\".join(cpio_path[: len(cpio_path) - 1])
                await run_command(['7z', 'x', filename, f'-o"{cpio_path}"'])

                filenames = await aio_glob(cpio_path + "\\*.cpio")
                filename = filenames[0]

                await run_command(['7z', 'x', filename, f'-o"{extraction_path}"'])
                if os.path.isfile(filename):
                    await aio_rmfile(filename)
        return 0

    @classmethod
    async def extract_file_deb(cls, filename, extraction_path):
        """ Extract debian packages """
        if not await aio_inpath("ar"):
            raise Exception("'ar' is required to extract deb files")
        else:
            current_dir = os.path.abspath(os.curdir)
            os.chdir(extraction_path)
            await run_command(["ar", "x", filename])
            os.chdir(current_dir)
            datafile = await aio_glob(os.path.join(extraction_path, "data.tar.*"))
            try:
                await aio_unpack_archive(datafile[0], extraction_path)
            except Exception:
                return 1
            return 0

    @classmethod
    async def extract_file_cab(cls, filename, extraction_path):
        """ Extract cab files """
        if sys.platform.startswith("linux"):
            if not await aio_inpath("cabextract"):
                raise Exception("'cabextract' is required to extract cab files")
            else:
                await run_command(["cabextract", "-d", extraction_path, filename])
        else:
            await run_command(["Expand", filename, "-F:*", extraction_path])
        return 0

    @classmethod
    async def extract_file_zip(cls, filename, extraction_path):
        """ Extract zip files """
        if await aio_inpath("unzip"):
            await run_command(
                ["unzip", "-qq", "-n", "-d", extraction_path, filename]
            )
        elif await aio_inpath("7z"):
            await run_command(['7z', 'x', filename, f'-o"{extraction_path}"'])
        else:
            try:
                await aio_unpack_archive(filename, extraction_path)
            except Exception:
                return 1
        return 0


class TempDirExtractorContext(BaseExtractor):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, raise_failure=False, *args, **kwargs):
        BaseExtractor.__init__(self, *args, **kwargs)
        self.tempdir = None
        self.raise_failure = raise_failure

    async def extract(self, filename):
        """ Run the extractor """
        # Resolve path in case of cwd change
        filename = os.path.abspath(filename)
        for extractor in self.file_extractors:
            for extension in self.file_extractors[extractor]:
                if filename.endswith(extension):
                    extracted_path = os.path.join(
                        self.tempdir, f"{os.path.basename(filename)}.extracted"
                    )
                    if os.path.exists(extracted_path):
                        await aio_rmdir(extracted_path)
                    await aio_makedirs(extracted_path, 0o700)
                    if await extractor(filename, extracted_path) != 0:
                        if self.raise_failure:
                            raise ExtractionFailed(filename)
                        else:
                            self.logger.warning(f"Failure extracting {filename}")
                    else:
                        self.logger.debug(f"Extracted {filename} to {extracted_path}")
                    return extracted_path
        raise UnknownArchiveType(filename)

    async def __aenter__(self):
        """ Create a temporary directory to extract files to. """
        self.tempdir = await aio_mkdtemp(prefix="cve-bin-tool-")
        return self

    async def __aexit__(self, exc_type, exc, exc_tb):
        """ Removes all extraction directories that need to be cleaned up."""
        # await aio_rmdir(self.tempdir)


class Extractor(BaseExtractor):
    """Provides a context which extraction is done in"""

    def __call__(self, *args, **kwargs):
        return TempDirExtractorContext(*args, **kwargs)
