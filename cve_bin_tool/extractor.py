# pylint: disable=useless-object-inheritance, keyword-arg-before-vararg
# disabled for python2 compatibility reasons
"""
Extraction of archives
"""
import os
import glob
import shutil
import tempfile
import itertools
import subprocess
import tarfile
import zipfile
import unix_ar
from contextlib import contextmanager

from .log import LOGGER
from .util import inpath


class ExtractionFailed(ValueError):
    """ Extraction fail """

    # pass


class UnknownArchiveType(ValueError):
    """ Unknown archive type"""

    # pass

def run_win_cmd(cmd):
    result = []
    process = subprocess.Popen(cmd,
                               shell=True,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    for line in process.stdout:
        result.append(line)
    errcode = process.returncode
    for line in result:
        print(line)
    if errcode is not None:
        raise Exception('cmd %s failed, see above for details', cmd)

@contextmanager
def popen_ctx(*args, **kwargs):
    """ Python 2 does not support context manager style Popen."""
    proc = subprocess.Popen(*args, **kwargs)
    try:
        yield proc
    finally:
        if "stdout" in kwargs:
            proc.stdout.close()
        proc.terminate()
        proc.wait()


class BaseExtractor(object):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, logger=None):
        """Sets up logger and if we should extract files or just report"""
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        self.logger = logger
        self.file_extractors = {
            self.extract_file_tar: [".tgz", ".tar.gz", ".tar", ".tar.xz", ".tar.bz2"],
            self.extract_file_rpm: [".rpm"],
            self.extract_file_deb: [".deb", ".ipk"],
            self.extract_file_cab: [".cab"],
            self.extract_file_zip: [".exe", ".zip", ".jar", ".apk"],
        }

    def can_extract(self, filename):
        """ Check if the filename is something we know how to extract """
        for extention in itertools.chain(*self.file_extractors.values()):
            if filename[::-1].startswith(extention[::-1]):
                return True
        return False

    @classmethod
    def extract_file_tar(cls, filename, extraction_path):
        """ Extract tar files """
        if not inpath("tar"):
            """ Acutally MinGW provides tar, so this might never get called """
            tar = tarfile.open(filename)
            tar.extractall(path=extraction_path)
            tar.close()
        else:
            return subprocess.call(["tar", "-C", extraction_path, "-axf", filename])

    @classmethod
    def extract_file_rpm(cls, filename, extraction_path):
        """ Extract rpm packages """
        if not inpath("rpm2cpio") or not inpath("cpio"):
            if not inpath("7z"):
                print ("Error: need '7z' binary not in path")
            else:
                run_win_cmd("7z x " + filename + " -o" + extraction_path)
        else:
            with popen_ctx(["rpm2cpio", filename], stdout=subprocess.PIPE) as proc:
                return subprocess.call(
                    ["cpio", "-idmv"], stdin=proc.stdout, cwd=extraction_path
                )

    @classmethod
    def extract_file_deb(cls, filename, extraction_path):
        """ Extract debian packages """
        if not inpath("ar"):
            """ Acutally MinGW provides ar, so this might never get called """
            archive = unix_ar.open(filename, "r")
            archive.extractall(extraction_path)
            archive.close()
            datafile = glob.glob(os.path.join(extraction_path, "data.tar.*"))[0]
            if not inpath("tar"):
                tar = tarfile.open(datafile)
                tar.extractall(path=extraction_path)
                tar.close()
            else:
                result = subprocess.call(
                    ["tar", "-C", extraction_path, "-axf", datafile]
                )
                return result
        else:
            result = subprocess.call(["ar", "x", filename], cwd=extraction_path)
            if result != 0:
                return result
            if not inpath("tar"):
                print("Error: need 'tar' binary not in path")
            else:
                datafile = glob.glob(os.path.join(extraction_path, "data.tar.*"))[0]
                result = subprocess.call(
                    ["tar", "-C", extraction_path, "-axf", datafile]
                )
                return result

    @classmethod
    def extract_file_cab(cls, filename, extraction_path):
        """ Extract cab files """
        if not inpath("cabextract"):
            """ Windows provides Expand command to extract cab files """
            run_win_cmd("Expand " + filename + " -F:* " + extraction_path)
        else:
            return subprocess.call(["cabextract", "-d", extraction_path, filename])

    @classmethod
    def extract_file_zip(cls, filename, extraction_path):
        """ Extract zip files """
        if not inpath("unzip"):
            zipf = zipfile.open(filename)
            zipf.extractall(path=extraction_path)
            zipf.close()
        else:
            return subprocess.call(
                ["unzip", "-qq", "-n", "-d", extraction_path, filename]
            )


class TempDirExtractorContext(BaseExtractor):
    """Extracts tar, rpm, etc. files"""

    def __init__(self, raise_failure=False, *args, **kwargs):
        BaseExtractor.__init__(self, *args, **kwargs)
        self.tempdir = None
        self.raise_failure = raise_failure

    def extract(self, filename):
        """ Run the extractor """
        # Resolve path in case of cwd change
        filename = os.path.abspath(filename)
        for extractor in self.file_extractors:
            for extention in self.file_extractors[extractor]:
                if filename[::-1].startswith(extention[::-1]):
                    extracted_path = os.path.join(
                        self.tempdir, os.path.basename(filename) + ".extracted"
                    )
                    if os.path.exists(extracted_path):
                        shutil.rmtree(extracted_path)
                    os.makedirs(extracted_path)
                    if extractor(filename, extracted_path) != 0:
                        if self.raise_failure:
                            raise ExtractionFailed(filename)
                        else:
                            self.logger.warning("Failure extracting %r", filename)
                    else:
                        self.logger.debug(
                            "Extracted %r to %r", filename, extracted_path
                        )
                    return extracted_path
        raise UnknownArchiveType(filename)

    def __enter__(self):
        """ Create a temporary directory to extract files to. """
        self.tempdir = tempfile.mkdtemp(prefix="cve-bin-tool-")
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        """ Removes all extraction directories that need to be cleaned up."""
        shutil.rmtree(self.tempdir)


class Extractor(BaseExtractor):
    """Provides a context which extraction is done in"""

    def __call__(self, *args, **kwargs):
        return TempDirExtractorContext(*args, **kwargs)
