# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import asyncio
import io
import json
import zipfile
from pathlib import Path

import aiohttp

from cve_bin_tool.async_utils import FileIO
from cve_bin_tool.data_sources import DISK_LOCATION_DEFAULT, Data_Source
from cve_bin_tool.error_handler import ErrorMode
from cve_bin_tool.log import LOGGER

OSV_ECOSYSTEMS = [
    "Go",
    "UVI",
    "Debian:5.0",
    "Packagist",
    "Debian:3.1",
    "Debian:8",
    "Maven",
    "RubyGems",
    "Debian:3.0",
    "Linux",
    "Debian:9",
    "Debian:10",
    "NuGet",
    "JavaScript",
    "OSS-Fuzz",
    "Debian:6.0",
    "Debian:7",
    "Debian:4.0",
    "DWF",
    "npm",
    "crates.io",
    "Debian:11",
    "PyPI",
    "GSD",
    "Android",
    "Debian",
    "Hex",
]


class OSV_Source(Data_Source):

    CACHEDIR = DISK_LOCATION_DEFAULT
    ECOSYSTEMS = OSV_ECOSYSTEMS
    LOGGER = LOGGER.getChild("CVEDB")
    OSV_URL = "https://osv-vulnerabilities.storage.googleapis.com/"

    def __init__(self, error_mode: ErrorMode = ErrorMode.TruncTrace):
        self.cachedir = self.CACHEDIR
        self.ecosystems = self.ECOSYSTEMS
        self.osv_path = str(Path(self.cachedir) / "osv")

        self.error_mode = error_mode

        self.osv_url = self.OSV_URL
        self.all_cve_entries = []

    async def get_ecosystem(self, ecosystem_url):
        async with aiohttp.ClientSession() as session:
            async with session.get(ecosystem_url) as r:
                content = await r.read()
                return content

    async def fetch_cves(self):
        tasks = []

        LOGGER.info("Getting OSV CVEs...")
        for ecosystem in self.ecosystems:
            eco_url = self.osv_url + ecosystem + "/all.zip"
            task = self.get_ecosystem(eco_url)

            tasks.append(task)

        for r in await asyncio.gather(*tasks):

            z = zipfile.ZipFile(io.BytesIO(r))
            z.extractall(self.osv_path)

    async def update_cve_entries(self):
        p = Path(self.osv_path).glob("**/*")
        files = [x for x in p if x.is_file()]

        for file in files:
            async with FileIO(file, "r") as f:
                r = await f.read()
                data = json.loads(r)

                self.all_cve_entries.append(data)

    def format_data(self, all_cve_entries):
        severity_data = []
        affected_data = []

        for cve_item in all_cve_entries:
            cve_id = (
                cve_item.get("aliases")[0]
                if cve_item.get("aliases", None) is not None
                and "CVE" in cve_item.get("aliases")[0]
                else cve_item["id"]
            )

            cve = {
                "ID": cve_id,
                "severity": None,
                "description": cve_item.get("summary", None),
                "score": None,
                "CVSS_version": None,
                "CVSS_vector": None,
            }

            severity_data.append(cve)

            affected = {
                "cve_id": cve_id,
                "vendor": cve_item["affected"][0]["package"]["ecosystem"],
                "product": cve_item["affected"][0]["package"]["name"].split("/")[-1],
                "version": None,
                "versionStartIncluding": None,
                "versionStartExcluding": None,
                "versionEndIncluding": None,
                "versionEndExcluding": None,
            }

            affected_data.append(affected)

        return severity_data, affected_data

    async def get_cve_data(self):
        await self.fetch_cves()
        await self.update_cve_entries()

        return self.format_data(self.all_cve_entries)
