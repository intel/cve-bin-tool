# Copyright (C) 2024 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import re
from typing import Any, DefaultDict, Dict, Set, Union

from lib4vex.parser import VEXParser

from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import ProductInfo, Remarks

TriageData = Dict[str, Union[Dict[str, Any], Set[str]]]


class VEXParse:
    """
    A class for parsing VEX files and extracting necessary fields from the vulnerabilities.

    Attributes:
    - filename (str): The path to the VEX file.
    - vextype (str): The type of VEX file.
    - logger: The logger object for logging messages.
    - parsed_data: A dictionary to store the parsed data.

    Methods:
    - __init__(self, filename: str, vextype: str, logger=None): Initializes the VEXParse object.
    - parse_vex(self) -> DefaultDict[ProductInfo, TriageData]: Parses the VEX file and extracts the necessary fields from the vulnerabilities.
    - process_metadata(self) -> None: Processes the metadata.
    - process_product(self) -> None: Processes the product information.
    - process_vulnerabilities(self, vulnerabilities) -> None: Processes the vulnerabilities and extracts the necessary fields.
    - decode_bom_ref(self, ref) -> ProductInfo: Decodes the BOM reference for each component.
    - validate_product(self, product: str) -> bool: Validates if a product name conforms to the CPE 2.3 standard.
    """

    analysis_state = {
        "cyclonedx": {
            "in_triage": Remarks.NewFound,
            "exploitable": Remarks.Confirmed,
            "resolved": Remarks.Mitigated,
            "false_positive": Remarks.FalsePositive,
            "not_affected": Remarks.NotAffected,
        },
        # This is for csaf, csaf is not supported yet
        "csaf": {
            "first_affected": Remarks.NewFound,
            "first_fixed": Remarks.Mitigated,
            "fixed": Remarks.Mitigated,
            "known_affected": Remarks.Confirmed,
            "known_not_affected": Remarks.NotAffected,
            "last_affected": Remarks.Confirmed,
            "recommended": Remarks.Mitigated,
            "under_investigation": Remarks.NewFound,
        },
    }

    def __init__(self, filename: str, vextype: str, logger=None):
        self.filename = filename
        self.vextype = vextype
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.parsed_data = {}

    def parse_vex(self) -> DefaultDict[ProductInfo, TriageData]:
        """Parses the VEX file and extracts the necessary fields from the vulnerabilities."""
        vexparse = VEXParser(vex_type=self.vextype)
        vexparse.parse(self.filename)
        self.logger.debug(f"VEX Vulnerabilities: {vexparse.get_vulnerabilities()}")
        self.process_vulnerabilities(vexparse.get_vulnerabilities())
        # metadata will also be processed
        # self.process_metadata(vexparse.get_metadata())
        # we have product also to be processed
        # self.process_product(vexparse.get_product())
        return self.parsed_data

    def process_metadata(self) -> None:
        pass

    def process_product(self) -> None:
        pass

    def process_vulnerabilities(self, vulnerabilities) -> None:
        """ "processes the vulnerabilities and extracts the necessary fields from the vulnerability."""
        # for now cyclonedx is supported with minor tweaks other will be supported later
        for vuln in vulnerabilities:
            # Extract necessary fields from the vulnerability
            cve_id = vuln.get("id")
            remarks = self.analysis_state[self.vextype][vuln.get("status")]
            justification = vuln.get("justification")
            response = vuln.get("remediation")
            comments = vuln.get("comments")
            severity = vuln.get("severity")  # Severity is not available in Lib4VEX
            # Decode the bom reference for cyclonedx something similar would be done for other formats
            product_info = self.decode_bom_ref(vuln.get("bom_link"))
            if product_info:
                cve_data = {
                    "remarks": remarks,
                    "comments": comments if comments else "",
                    "response": response if response else [],
                }
                if justification:
                    cve_data["justification"] = justification.strip()

                if severity:
                    cve_data["severity"] = severity.strip()

                if product_info not in self.parsed_data:
                    self.parsed_data[product_info] = {}
                self.parsed_data[product_info][cve_id.strip()] = cve_data

                if "paths" not in self.parsed_data[product_info]:
                    self.parsed_data[product_info]["paths"] = {}

    def decode_bom_ref(self, ref) -> ProductInfo:
        """
        Decodes the BOM reference for each component.

        Args:
        - ref (str): BOM reference string

        Returns:
        - bool: ProductInfo object containing the vendor, product, and version.

        """
        # urn:cbt:{bom_version}/{vendor}#{product}-{version}
        urn_cbt_ref = re.compile(
            r"urn:cbt:(?P<bom_version>.*?)\/(?P<vendor>.*?)#(?P<product>.*?)-(?P<version>.*)"
        )

        # This URN was added to support CPE's that have dashes in their version field.
        # urn:cbt:{bom_version}/{vendor}#{product}:{version}
        urn_cbt_ext_ref = re.compile(
            r"urn:cbt:(?P<bom_version>.*?)\/(?P<vendor>.*?)#(?P<product>.*?):(?P<version>.*)"
        )

        # urn:cdx:serialNumber/version#bom-ref (https://cyclonedx.org/capabilities/bomlink/)
        urn_cdx = re.compile(
            r"urn:cdx:(?P<bomSerialNumber>.*?)\/(?P<bom_version>.*?)#(?P<bom_ref>.*)"
        )
        location = "location/to/product"
        if urn_cbt_ext_ref.match(ref):
            urn_dict = urn_cbt_ext_ref.match(ref).groupdict()
            vendor = urn_dict["vendor"]
            product = urn_dict["product"]
            version = urn_dict["version"]
        elif urn_cbt_ref.match(ref):
            urn_dict = urn_cbt_ref.match(ref).groupdict()
            vendor = urn_dict["vendor"]
            product = urn_dict["product"]
            version = urn_dict["version"]
        elif urn_cdx.match(ref):
            urn_dict = urn_cdx.match(ref).groupdict()
            cdx_bom_ref = urn_dict["bom_ref"]
            # Try to decode the CDX BOM reference. This can be any unique identifier but may contain
            #   product:version
            #   or it could be a Package URL.
            try:
                product, version = cdx_bom_ref.rsplit("-", 1)
            except ValueError:
                product, version = None, None
            vendor = "UNKNOWN"
        else:
            product = None
            version = None
            vendor = None

        product_info = None
        if product is not None and self.validate_product(product):
            product_info = ProductInfo(
                vendor.strip(), product.strip(), version.strip(), location
            )

        return product_info

    def validate_product(self, product: str) -> bool:
        """
        Validates if a product name conforms to the CPE 2.3 standard.
        Ensure product name conforms to CPE 2.3 standard.
        See https://csrc.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd for naming specification
        """
        cpe_regex = r"\A([A-Za-z0-9\._\-~ %])+\Z"
        return re.search(cpe_regex, product) is not None
