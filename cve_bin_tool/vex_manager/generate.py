# Copyright (C) 2024 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later
import os
from datetime import datetime
from logging import Logger
from pathlib import Path
from typing import Dict, List, Optional

from lib4sbom.data.vulnerability import Vulnerability
from lib4vex.generator import VEXGenerator

from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import CVEData, ProductInfo, Remarks


class VEXGenerate:
    analysis_state = {
        "cyclonedx": {
            Remarks.NewFound: "in_triage",
            Remarks.Unexplored: "in_triage",
            Remarks.Confirmed: "exploitable",
            Remarks.Mitigated: "resolved",
            Remarks.FalsePositive: "false_positive",
            Remarks.NotAffected: "not_affected",
        },
        "csaf": {
            Remarks.NewFound: "under_investigation",
            Remarks.Unexplored: "under_investigation",
            Remarks.Confirmed: "known_affected",
            Remarks.Mitigated: "fixed",
            Remarks.FalsePositive: "known_not_affected",
            Remarks.NotAffected: "known_not_affected",
        },
        "openvex": {
            Remarks.NewFound: "under_investigation",
            Remarks.Unexplored: "under_investigation",
            Remarks.Confirmed: "affected",
            Remarks.Mitigated: "fixed",
            Remarks.FalsePositive: "not_affected",
            Remarks.NotAffected: "not_affected",
        },
    }

    def __init__(
        self,
        product: str,
        release: str,
        vendor: str,
        filename: str,
        vextype: str,
        all_cve_data: Dict[ProductInfo, CVEData],
        sbom: Optional[str] = None,
        logger: Optional[Logger] = None,
        validate: bool = True,
    ):
        self.product = product
        self.release = release
        self.vendor = vendor
        self.sbom = sbom
        self.filename = filename
        self.vextype = vextype
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.validate = validate
        self.all_cve_data = all_cve_data

    def generate_vex(self) -> None:
        """
        Generates VEX code based on the specified VEX type.

        Returns:
            None
        """
        vexgen = VEXGenerator(vex_type=self.vextype)
        kwargs = {"name": self.product, "release": self.release}
        if self.sbom:
            kwargs["sbom"] = self.sbom
        vexgen.set_product(**kwargs)
        if Path(self.filename).is_file():
            self.logger.warning(
                f"Failed to write '{self.filename}'. File already exists"
            )
            self.logger.info("Generating a new filename with Default Naming Convention")
            self.filename = self.generate_vex_filename()
        vexgen.generate(
            project_name=self.product,
            vex_data=self.get_vulnerabilities(),
            metadata=self.get_metadata(),
            filename=self.filename,
        )

    def generate_vex_filename(self) -> str:
        """
        Generates a VEX filename based on the current date and time.

        Returns:
            str: The generated VEX filename.
        """
        now = datetime.now().strftime("%Y-%m-%d.%H-%M-%S")
        filename = os.path.abspath(
            os.path.join(
                os.getcwd(), f"{self.product}_{self.release}_{self.vextype}.{now}.json"
            )
        )
        return filename

    def get_metadata(self) -> Dict:
        metadata = {
            "id": f"{self.product.upper()}-{self.release}-VEX",
            "supplier": self.vendor,
        }
        # other metadata can be added here
        return metadata

    def get_vulnerabilities(self) -> List[Vulnerability]:
        """
        Retrieves a list of vulnerabilities.

        Returns:
            A list of Vulnerability objects representing the vulnerabilities.
        """
        vulnerabilities = []
        for product_info, cve_data in self.all_cve_data.items():
            vendor, product, version, _, purl = product_info
            for cve in cve_data["cves"]:
                if isinstance(cve, str):
                    continue
                vulnerability = Vulnerability(validation=self.vextype)
                vulnerability.initialise()
                vulnerability.set_name(product)
                vulnerability.set_release(version)
                vulnerability.set_id(cve.cve_number)
                vulnerability.set_description(cve.description)
                vulnerability.set_comment(cve.comments)
                vulnerability.set_status(self.analysis_state[self.vextype][cve.remarks])
                if cve.justification:
                    vulnerability.set_justification(cve.justification)
                # vulnerability.set_remediation(cve.response)
                detail = (
                    f"{cve.remarks.name}: {cve.comments}"
                    if cve.comments
                    else cve.remarks.name
                )
                # more details will be added using set_value()
                bom_version = 1
                ref = f"urn:cbt:{bom_version}/{vendor}#{product}:{version}"
                if purl is None:
                    purl = f"pkg:generic/{vendor}/{product}@{version}"

                vulnerability.set_value("purl", purl)
                vulnerability.set_value("bom_link", ref)
                vulnerability.set_value("action", detail)
                vulnerability.set_value("source", cve.data_source)
                vulnerability.set_value("updated", cve.last_modified)
                # vulnerability.show_vulnerability()
                vulnerabilities.append(vulnerability.get_vulnerability())
        self.logger.debug(f"Vulnerabilities: {vulnerabilities}")
        return vulnerabilities
