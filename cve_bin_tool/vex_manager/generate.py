# Copyright (C) 2024 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later
import os
from datetime import datetime
from logging import Logger
from pathlib import Path

from lib4sbom.data.vulnerability import Vulnerability
from lib4vex.generator import VEXGenerator

from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import CVEData, ProductInfo, Remarks


class VEXGenerate:
    analysis_state = {
        "cyclonedx": {
            Remarks.NewFound: "in_triage",
            Remarks.Unexplored: "in_triage",
            Remarks.Confirmed: "exploitable",
            Remarks.Mitigated: "resolved",
            Remarks.FalsePositive: "false_positive",
            Remarks.NotAffected: "not_affected",
        }
    }

    def __init__(
        self,
        filename: str,
        all_cve_data: dict[ProductInfo, CVEData],
        vextype: str,
        logger: Logger | None = None,
        validate: bool = True,
    ):
        self.filename = filename
        self.vextype = vextype
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.validate = validate
        self.all_cve_data = all_cve_data

    def generate_vex(self) -> None:
        """
        Generates VEX code based on the specified VEX type.

        Returns:
            None
        """
        vexgen = VEXGenerator(vex_type=self.vextype)
        vexgen.set_product(name="generation-draft", release="1.0")
        if Path(self.filename).is_file():
            self.logger.warning(
                f"Failed to write '{self.filename}'. File already exists"
            )
            self.logger.info("Generating a new filename with Default Naming Convention")
            self.filename = self.generate_vex_filename()
        vexgen.generate(
            project_name="generation-draft",
            vex_data=self.get_vulnerabilities(),
            metadata=self.get_metadata(),
            filename=self.filename,
        )

    def generate_vex_filename(self) -> str:
        """
        Generates a VEX filename based on the current date and time.

        Returns:
            str: The generated VEX filename.
        """
        now = datetime.now().strftime("%Y-%m-%d.%H-%M-%S")
        filename = os.path.abspath(
            os.path.join(os.getcwd(), f"prle.{self.vextype}.{now}.json")
        )
        return filename

    def get_metadata(self) -> dict:
        metadata = {}
        return metadata

    def get_vulnerabilities(self) -> list[Vulnerability]:
        """
        Retrieves a list of vulnerabilities.

        Returns:
            A list of Vulnerability objects representing the vulnerabilities.
        """
        vulnerabilities = []
        for product_info, cve_data in self.all_cve_data.items():
            product, version, _, _ = product_info
            for cve in cve_data["cves"]:
                if isinstance(cve, str):
                    continue
                vulnerability = Vulnerability(validation=self.vextype)
                vulnerability.initialise()
                vulnerability.set_name(product)
                vulnerability.set_release(version)
                vulnerability.set_id(cve.cve_number)
                vulnerability.set_description(cve.description)
                vulnerability.set_comment(cve.comments)
                vulnerability.set_status(self.analysis_state[self.vextype][cve.remarks])
                if cve.justification:
                    vulnerability.set_justification(cve.justification)
                # vulnerability.set_remediation(cve.response)
                detail = (
                    f"{cve.remarks.name}: {cve.comments}"
                    if cve.comments
                    else cve.remarks.name
                )
                # more details will be added using set_value()
                vulnerability.set_value("action", detail)
                vulnerability.set_value("source", cve.data_source)
                vulnerability.set_value("updated", cve.last_modified)
                # vulnerability.show_vulnerability()
                vulnerabilities.append(vulnerability.get_vulnerability())
        self.logger.debug(f"Vulnerabilities: {vulnerabilities}")
        return vulnerabilities
