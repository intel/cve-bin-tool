# Copyright (C) 2021 Anthony Harrison
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import annotations

import re
from collections import defaultdict
from logging import Logger
from pathlib import Path

import defusedxml.ElementTree as ET
from lib4sbom.parser import SBOMParser
from packageurl import PackageURL

from cve_bin_tool.cvedb import CVEDB
from cve_bin_tool.input_engine import TriageData
from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import ProductInfo, Remarks
from cve_bin_tool.validator import validate_cyclonedx, validate_spdx

from .swid_parser import SWIDParser


class SBOMManager:
    """
    Class: InputEngine

    This class is responsible for parsing various SBOM file formats (SPDX,
    CycloneDX, SWID) in the CVE Bin Tool.

    Attributes:
    - sbom_data (DefaultDict[ProductInfo, TriageData]): Dictionary containing parsed SBOM data.

    """

    SBOMtype = ["spdx", "cyclonedx", "swid"]

    sbom_data: defaultdict[ProductInfo, TriageData]

    def __init__(
        self,
        filename: str,
        sbom_type: str = "spdx",
        logger: Logger | None = None,
        validate: bool = True,
    ):
        self.filename = filename
        self.sbom_data = defaultdict(dict)
        self.type = "unknown"
        if sbom_type in self.SBOMtype:
            self.type = sbom_type
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.validate = validate

        # Connect to the database
        self.cvedb = CVEDB(version_check=False)

    def scan_file(self) -> dict[ProductInfo, TriageData]:
        """
        Parses the SBOM input file and returns the product information and
        corresponding triage data.

        Returns:
        - dict[ProductInfo, TriageData]: Parsed SBOM data.

        """
        self.logger.debug(
            f"Processing SBOM {self.filename} of type {self.type.upper()}"
        )
        modules = []
        try:
            if Path(self.filename).exists():
                if self.type == "swid":
                    swid = SWIDParser(self.validate)
                    modules = swid.parse(self.filename)
                else:
                    modules = self.parse_sbom()
        except (KeyError, FileNotFoundError, ET.ParseError) as e:
            LOGGER.debug(e, exc_info=True)

        LOGGER.debug(
            f"The number of modules identified in SBOM - {len(modules)}\n{modules}"
        )

        # Now process list of modules to create [vendor, product, version] tuples
        parsed_data: list[ProductInfo] = []
        for m in modules:
            if m and m[1]:
                # Using lower to normalize product names across databases
                module_vendor, product, version = m[0], m[1].lower(), m[2]
                if version != "" and module_vendor is None:
                    # Now add vendor to create product record....
                    vendor_set = self.get_vendor(product)
                    for vendor in vendor_set:
                        # if vendor is not None:
                        parsed_data.append(ProductInfo(vendor, product, version))
                else:
                    parsed_data.append(ProductInfo(module_vendor, product, version))

        for row in parsed_data:
            self.sbom_data[row]["default"] = {
                "remarks": Remarks.NewFound,
                "comments": "",
                "severity": "",
            }
            self.sbom_data[row]["paths"] = set(map(lambda x: x.strip(), "".split(",")))

        LOGGER.debug(f"SBOM Data {self.sbom_data}")
        return self.sbom_data

    def get_vendor(self, product: str) -> list:
        """
        Get the list of vendors for the product name.

        There may be more than one vendor for a given product name and all
        matches are returned.

        Args:
        - product (str): Product name.

        Returns:
        - list: The list of vendors for the product

        """
        vendorlist: list[str] = []
        vendor_package_pair = self.cvedb.get_vendor_product_pairs(product)
        if vendor_package_pair:
            # To handle multiple vendors, return all combinations of product/vendor mappings
            for v in vendor_package_pair:
                vendor = v["vendor"]
                vendorlist.append(vendor)
        else:
            vendorlist.append("UNKNOWN")
        return vendorlist

    def is_valid_purl(self, purl_string):
        """Returns true if give purl_string is a valid purl string"""
        purl_pattern = r"^\w+://[\w\-.]+/[\w\-.]+(?:/[\w\-.]+)*(?:\?[\w\-.]+=[\w\-.]+(?:&[\w\-.]+=[\w\-.]+)*)?$"
        return re.match(purl_pattern, purl_string) is not None

    def parse_sbom(self):
        """parse SBOM, using PURL identifiers preferentially if found"""

        # Set up SBOM parser
        sbom_parser = SBOMParser(sbom_type=self.type)
        # Load SBOM
        sbom_parser.parse_file(self.filename)
        modules = []
        if self.validate and self.filename.endswith(".xml"):
            # Only for XML files
            if sbom_parser.get_type() == "spdx":
                valid_xml = validate_spdx(self.filename)
            else:
                valid_xml = validate_cyclonedx(self.filename)
            if not valid_xml:
                return modules
        packages = [x for x in sbom_parser.get_sbom()["packages"].values()]
        LOGGER.debug(f"Parsed SBOM {self.filename} {packages}")
        for package in packages:
            ext_ref_found = False
            # If PURL or CPE record found, use this data in preference to package data
            ext_ref = package.get("externalreference")
            if ext_ref is not None:
                # Make two passes through the ext ref, and give priority to CPE type
                # which will always match the CVE database.
                for ref in ext_ref:
                    if ref[1] == "cpe23Type":
                        cpe = ref[2].split(":")
                        vendor, product, version = cpe[3], cpe[4], cpe[5]
                        modules.append([vendor, product, version])
                        ext_ref_found = True
                        break
                else:
                    for ref in ext_ref:
                        if ref[1] == "purl":
                            if self.is_valid_purl(ref[2]):
                                # Process purl identifier
                                purl_info = PackageURL.from_string(ref[2]).to_dict()
                                if purl_info["name"] and purl_info["version"]:
                                    vendor = None
                                    modules.append(
                                        [
                                            vendor,
                                            purl_info["name"],
                                            purl_info["version"],
                                        ]
                                    )
                                    ext_ref_found = True
            if not ext_ref_found:
                if package.get("version") is not None:
                    vendor = None
                    modules.append([vendor, package["name"], package["version"]])
                else:
                    LOGGER.debug(f"No version found in {package}")
        LOGGER.debug(f"Parsed SBOM {self.filename} {modules}")
        return modules


if __name__ == "__main__":
    import sys

    file = sys.argv[1]
    sbom = SBOMManager(file)
    sbom.scan_file()
