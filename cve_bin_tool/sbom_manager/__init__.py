# Copyright (C) 2021 Anthony Harrison
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import annotations

import re
import sys
from collections import defaultdict
from logging import Logger
from pathlib import Path

import defusedxml.ElementTree as ET
from lib4sbom.parser import SBOMParser
from packageurl import PackageURL

from cve_bin_tool.cvedb import CVEDB
from cve_bin_tool.input_engine import TriageData
from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import (
    ProductInfo,
    Remarks,
    find_product_location,
    validate_location,
)
from cve_bin_tool.validator import validate_cyclonedx, validate_spdx

from .swid_parser import SWIDParser


class SBOMManager:
    """
    SBOMManager is a class that manages the Software Bill of Materials (SBOM) data.
    It provides methods for scanning SBOM files, parsing them, and retrieving vendor information.
    """

    SBOMtype = ["spdx", "cyclonedx", "swid"]

    sbom_data: defaultdict[ProductInfo, TriageData]

    def __init__(
        self,
        filename: str,
        sbom_type: str = "spdx",
        logger: Logger | None = None,
        validate: bool = True,
    ):
        self.filename = filename
        self.sbom_data = defaultdict(dict)
        self.type = "unknown"
        if sbom_type in self.SBOMtype:
            self.type = sbom_type
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.validate = validate

        # Connect to the database
        self.cvedb = CVEDB(version_check=False)

    def common_prefix_split(self, product, version) -> list[ProductInfo]:
        """If the product have '-' in name try splitting it and try common prefixes.
        currently not being used, proposed to be used in future"""
        parsed_data: list[ProductInfo] = []
        found_common_prefix = False
        common_prefix = (
            "perl-",
            "golang-",
            "rubygem-",
            "python-",
            "py3-",
            "python3-",
            "python2-",
            "rust-",
            "nodejs-",
        )
        for prefix in common_prefix:
            if product.startswith(prefix):
                common_prefix_product = product[len(prefix) :]
                common_prefix_vendor = self.get_vendor(common_prefix_product)
                if len(common_prefix_vendor) > 1 or (
                    len(common_prefix_vendor) == 1
                    and common_prefix_vendor[0] != "UNKNOWN"
                ):
                    location = find_product_location(common_prefix_product)
                    if location is None:
                        location = "NotFound"
                    if validate_location(location) is False:
                        raise ValueError(f"Invalid location {location} for {product}")
                    found_common_prefix = True
                    for vendor in common_prefix_vendor:
                        parsed_data.append(
                            ProductInfo(
                                vendor, common_prefix_product, version, location
                            )
                        )
                break
        if not found_common_prefix:
            # if vendor not found after removing common prefix try splitting it
            LOGGER.debug(
                f"No Vendor found for {product}, trying splitted product. "
                "Some results may be inaccurate due to vendor identification limitations."
            )
            splitted_product = product.split("-")
            for sp in splitted_product:
                temp = self.get_vendor(sp)
                if len(temp) > 1 or (len(temp) == 1 and temp[0] != "UNKNOWN"):
                    for vendor in temp:
                        location = find_product_location(sp)
                        if location is None:
                            location = "NotFound"
                        if validate_location(location) is False:
                            raise ValueError(
                                f"Invalid location {location} for {product}"
                            )
                        # if vendor is not None:
                        parsed_data.append(ProductInfo(vendor, sp, version, location))
        return parsed_data

    def scan_file(self) -> dict[ProductInfo, TriageData]:
        """
        Parses the SBOM input file and returns the product information and corresponding triage data.
        Returns:
        - dict[ProductInfo, TriageData]: Parsed SBOM data.
        """
        self.logger.debug(
            f"Processing SBOM {self.filename} of type {self.type.upper()}"
        )
        modules = []
        try:
            if Path(self.filename).exists():
                if self.type == "swid":
                    swid = SWIDParser(self.validate)
                    modules = swid.parse(self.filename)
                else:
                    modules = self.parse_sbom()
        except (KeyError, FileNotFoundError, ET.ParseError) as e:
            LOGGER.debug(e, exc_info=True)
        LOGGER.debug(
            f"The number of modules identified in SBOM - {len(modules)}\n{modules}"
        )

        parsed_data: list[ProductInfo] = []
        for m in modules:
            if m and m[0]:
                # Using lower to normalize product names across databases
                product, version = m[0].lower(), m[1]
                if version != "":
                    # Now add vendor to create product record....
                    vendor_set = self.get_vendor(product)
                    for vendor in vendor_set:
                        location = find_product_location(product)
                        if location is None:
                            location = "NotFound"
                        if validate_location(location) is False:
                            raise ValueError(
                                f"Invalid location {location} for {product}"
                            )
                        parsed_data.append(
                            ProductInfo(vendor, product, version, location)
                        )

        for row in parsed_data:
            self.sbom_data[row]["default"] = {
                "remarks": Remarks.NewFound,
                "comments": "",
                "severity": "",
            }
            self.sbom_data[row]["paths"] = set(map(lambda x: x.strip(), "".split(",")))
        LOGGER.debug(f"SBOM Data {self.sbom_data}")
        return self.sbom_data

    def get_vendor(self, product: str) -> list:
        vendorlist: list[str] = []
        vendor_package_pair = self.cvedb.get_vendor_product_pairs(product)
        if vendor_package_pair != []:
            # To handle multiple vendors, return all combinations of product/vendor mappings
            for v in vendor_package_pair:
                vendor = v["vendor"]
                vendorlist.append(vendor)
        else:
            vendorlist.append("UNKNOWN")
        return vendorlist

    def is_valid_purl(self, purl_string):
        """Returns true if give purl_string is a valid purl string"""
        purl_pattern = r"^\w+://[\w\-.]+/[\w\-.]+(?:/[\w\-.]+)*(?:\?[\w\-.]+=[\w\-.]+(?:&[\w\-.]+=[\w\-.]+)*)?$"
        return re.match(purl_pattern, purl_string) is not None

    def parse_sbom(self):
        """parse SBOM, using PURL identifiers preferentially if found"""

        # Set up SBOM parser
        sbom_parser = SBOMParser(sbom_type=self.type)
        # Load SBOM
        sbom_parser.parse_file(self.filename)
        modules = []
        if self.validate and self.filename.endswith(".xml"):
            # Only for XML files
            if sbom_parser.get_type() == "spdx":
                valid_xml = validate_spdx(self.filename)
            else:
                valid_xml = validate_cyclonedx(self.filename)
            if not valid_xml:
                return modules
        packages = [x for x in sbom_parser.get_sbom()["packages"].values()]
        LOGGER.debug(f"Parsed SBOM {self.filename} {packages}")
        for package in packages:
            purl_found = False
            # If PURL record found, use this data in preference to package data
            ext_ref = package.get("externalreference")
            if ext_ref is not None:
                for ref in ext_ref:
                    if ref[1] == "purl":
                        if self.is_valid_purl(ref[2]):
                            # Process purl identifier
                            purl_info = PackageURL.from_string(ref[2]).to_dict()
                            if purl_info["name"] and purl_info["version"]:
                                modules.append(
                                    [purl_info["name"], purl_info["version"]]
                                )
                                purl_found = True
            if not purl_found:
                if package.get("version") is not None:
                    modules.append([package["name"], package["version"]])
                else:
                    LOGGER.debug(f"No version found in {package}")
        LOGGER.debug(f"Parsed SBOM {self.filename} {modules}")
        return modules


if __name__ == "__main__":

    file = sys.argv[1]
    sbom = SBOMManager(file)
    sbom.scan_file()
