import os
import sqlite3
from string import ascii_lowercase
from typing import NamedTuple

from pkg_resources import parse_version

from .cvedb import DISK_LOCATION_DEFAULT, DBNAME


class CVE(NamedTuple):
    cve_number: str
    severity: str
    description: str = ""


class CVEScanner:
    """
    This class is for reading CVEs from the database
    """

    RANGE_UNSET = ""
    dbname = os.path.join(DISK_LOCATION_DEFAULT, DBNAME)

    def get_cves(self, vendor, product, version, score):
        """ Get CVEs against a specific version of a product.

        Example:
            nvd.get_cves('haxx', 'curl', '7.34.0')
        """

        # Check for anything directly marked
        query = """
        SELECT CVE_number FROM cve_range
        WHERE vendor=? AND product=? AND version=?
        """
        self.cursor.execute(query, [vendor, product, version])
        cve_list = list(map(lambda x: x[0], self.cursor.fetchall()))

        # Check for any ranges
        query = """
        SELECT 
            CVE_number,
            versionStartIncluding, 
            versionStartExcluding, 
            versionEndIncluding, 
            versionEndExcluding 
        FROM cve_range 
        WHERE vendor=? AND product=? AND version=?
        """
        self.cursor.execute(query, [vendor, product, "*"])
        for cve_range in self.cursor:
            (
                cve_number,
                versionStartIncluding,
                versionStartExcluding,
                versionEndIncluding,
                versionEndExcluding,
            ) = cve_range

            # pep-440 doesn't include versions of the type 1.1.0g used by openssl
            # so if this is openssl, convert the last letter to a .number
            if product == "openssl":
                # if last character is a letter, convert it to .number
                version = self.openssl_convert(version)
                versionStartIncluding = self.openssl_convert(versionStartIncluding)
                versionStartExcluding = self.openssl_convert(versionStartExcluding)
                versionEndIncluding = self.openssl_convert(versionEndIncluding)
                versionEndExcluding = self.openssl_convert(versionEndExcluding)

            parsed_version = parse_version(version)

            # check the start range
            passes_start = False
            if (
                versionStartIncluding is not self.RANGE_UNSET
                and parsed_version >= parse_version(versionStartIncluding)
            ):
                passes_start = True
            if (
                versionStartExcluding is not self.RANGE_UNSET
                and parsed_version > parse_version(versionStartExcluding)
            ):
                passes_start = True

            if (
                versionStartIncluding is self.RANGE_UNSET
                and versionStartExcluding is self.RANGE_UNSET
            ):
                # then there is no start range so just say true
                passes_start = True

            # check the end range
            passes_end = False
            if (
                versionEndIncluding is not self.RANGE_UNSET
                and parsed_version <= parse_version(versionEndIncluding)
            ):
                passes_end = True

            if (
                versionEndExcluding is not self.RANGE_UNSET
                and parsed_version < parse_version(versionEndExcluding)
            ):
                passes_end = True
            if (
                versionEndIncluding is self.RANGE_UNSET
                and versionEndExcluding is self.RANGE_UNSET
            ):
                # then there is no end range so it passes
                passes_end = True
            # if it fits into both ends of the range, add the cve number
            if passes_start and passes_end:
                cve_list.append(cve_number)

        # Go through and get all the severities
        if cve_list:
            query = f"""
            SELECT CVE_number, severity, description 
            FROM cve_severity 
            WHERE CVE_number IN ({",".join(["?"] * len(cve_list))}) AND score >= ? 
            ORDER BY CVE_number
            """
            # Add score parameter to tuple listing CVEs to pass to query
            cve_list.append(score)

            result = self.cursor.execute(query, cve_list)

            cves = []
            for row in result:
                cve = CVE(**row)
                cves.append(cve)
            return cves
        return []  # return empty list if cve_list is empty

    @staticmethod
    def openssl_convert(version):
        """ pkg_resources follows pep-440 which doesn't expect openssl style 1.1.0g version numbering
        So to fake it, if the last character is a letter, replace it with .number before comparing """
        if len(version) < 1:
            return version

        lastchar = version[len(version) - 1]
        letters = dict(zip(ascii_lowercase, range(26)))

        if lastchar in letters:
            version = f"{version[0: len(version) - 1]}.{letters[lastchar]}"
        return version

    def __enter__(self):
        self.connection = sqlite3.connect(self.dbname)
        self.connection.row_factory = sqlite3.Row
        self.cursor = self.connection.cursor()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cursor.close()
        self.connection.close()
