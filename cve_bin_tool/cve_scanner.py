import os
import sqlite3
import sys
from logging import Logger
from string import ascii_lowercase
from typing import NamedTuple, List, Set, Dict

from pkg_resources import parse_version
from rich.columns import Columns
from rich.console import Console
from rich.panel import Panel

from .cvedb import DISK_LOCATION_DEFAULT, DBNAME
from .input_engine import Remarks
from .log import LOGGER


class CVE(NamedTuple):
    cve_number: str
    severity: str
    description: str = ""


class CVEData(NamedTuple):
    vendor: str
    product: str
    version: str
    remarks: Remarks
    cves: List[CVE]

    def __hash__(self):
        return hash((self.vendor, self.product, self.version))

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __ne__(self, other):
        return hash(self) != hash(other)


class CVEScanner:
    """
    This class is for reading CVEs from the database
    """

    products_with_cve: int
    products_without_cve: int
    all_cves: Set[CVEData]

    RANGE_UNSET: str = ""
    dbname: str = os.path.join(DISK_LOCATION_DEFAULT, DBNAME)
    CONSOLE: Console = Console(file=sys.stderr)
    ALPHA_TO_NUM: Dict[str, int] = dict(zip(ascii_lowercase, range(26)))

    def __init__(self, score: int = 0, logger: Logger = None):
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.score = score
        self.products_with_cve = 0
        self.products_without_cve = 0
        self.all_cves = set()

    def get_cves(self, vendor: str, product: str, version: str, remarks: Remarks):
        """ Get CVEs against a specific version of a product.

        Example:
            nvd.get_cves('haxx', 'curl', '7.34.0')
        """

        # Check for anything directly marked
        query = """
        SELECT CVE_number FROM cve_range
        WHERE vendor=? AND product=? AND version=?
        """
        self.cursor.execute(query, [vendor, product, version])
        cve_list = list(map(lambda x: x[0], self.cursor.fetchall()))

        # Check for any ranges
        query = """
        SELECT 
            CVE_number,
            versionStartIncluding, 
            versionStartExcluding, 
            versionEndIncluding, 
            versionEndExcluding 
        FROM cve_range 
        WHERE vendor=? AND product=? AND version=?
        """
        self.cursor.execute(query, [vendor, product, "*"])
        for cve_range in self.cursor:
            (
                cve_number,
                versionStartIncluding,
                versionStartExcluding,
                versionEndIncluding,
                versionEndExcluding,
            ) = cve_range

            # pep-440 doesn't include versions of the type 1.1.0g used by openssl
            # so if this is openssl, convert the last letter to a .number
            if product == "openssl":
                # if last character is a letter, convert it to .number
                version = self.openssl_convert(version)
                versionStartIncluding = self.openssl_convert(versionStartIncluding)
                versionStartExcluding = self.openssl_convert(versionStartExcluding)
                versionEndIncluding = self.openssl_convert(versionEndIncluding)
                versionEndExcluding = self.openssl_convert(versionEndExcluding)

            parsed_version = parse_version(version)

            # check the start range
            passes_start = False
            if (
                versionStartIncluding is not self.RANGE_UNSET
                and parsed_version >= parse_version(versionStartIncluding)
            ):
                passes_start = True
            if (
                versionStartExcluding is not self.RANGE_UNSET
                and parsed_version > parse_version(versionStartExcluding)
            ):
                passes_start = True

            if (
                versionStartIncluding is self.RANGE_UNSET
                and versionStartExcluding is self.RANGE_UNSET
            ):
                # then there is no start range so just say true
                passes_start = True

            # check the end range
            passes_end = False
            if (
                versionEndIncluding is not self.RANGE_UNSET
                and parsed_version <= parse_version(versionEndIncluding)
            ):
                passes_end = True

            if (
                versionEndExcluding is not self.RANGE_UNSET
                and parsed_version < parse_version(versionEndExcluding)
            ):
                passes_end = True
            if (
                versionEndIncluding is self.RANGE_UNSET
                and versionEndExcluding is self.RANGE_UNSET
            ):
                # then there is no end range so it passes
                passes_end = True
            # if it fits into both ends of the range, add the cve number
            if passes_start and passes_end:
                cve_list.append(cve_number)

        # Go through and get all the severities
        if cve_list:
            query = f"""
            SELECT CVE_number, severity, description 
            FROM cve_severity 
            WHERE CVE_number IN ({",".join(["?"] * len(cve_list))}) AND score >= ? 
            ORDER BY CVE_number
            """
            # Add score parameter to tuple listing CVEs to pass to query
            cve_list.append(self.score)

            result = self.cursor.execute(query, cve_list)

            cves: List[CVE] = []
            for row in result:
                cve = CVE(**row)
                cves.append(cve)

            cve_data = CVEData(vendor, product, version, remarks, cves)
            if cves:
                self.products_with_cve += 1
                self.logger.info(f"Known CVEs in {product}-{version}")
                self.CONSOLE.print(
                    Columns(
                        [Panel(f"[yellow]{cve.cve_number}[/yellow]") for cve in cves]
                    ),
                )
            else:
                self.products_without_cve += 1
            self.all_cves.add(cve_data)

    def openssl_convert(self, version: str) -> str:
        """ pkg_resources follows pep-440 which doesn't expect openssl style 1.1.0g version numbering
        So to fake it, if the last character is a letter, replace it with .number before comparing """
        if not version:  # if version is empty return it.
            return version

        lastchar = version[-1]

        if lastchar in self.ALPHA_TO_NUM:
            version = f"{version[:-1]}.{self.ALPHA_TO_NUM[lastchar]}"
        return version

    def affected(self):
        """ Returns list of product name and version tuples identified from
        scan"""
        return [(cve_data.product, cve_data.version) for cve_data in self.all_cves]

    def __enter__(self):
        self.connection = sqlite3.connect(self.dbname)
        self.connection.row_factory = sqlite3.Row
        self.cursor = self.connection.cursor()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cursor.close()
        self.connection.close()
