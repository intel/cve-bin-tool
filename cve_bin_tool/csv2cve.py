#!/usr/bin/python3
from __future__ import print_function

import argparse
import csv
import logging
import sys

from .OutputEngine import OutputEngine
from .cli import LogAction
from .cve_scanner import CVE, CVEScanner
from .cvedb import CVEDB, EmptyCache
from .log import LOGGER
from .version_scanner import CVEData


class CSV2CVE:
    """Generate CVE Output from a CSV file """

    ERR_BADCSV = -1
    ERR_MISSINGCOLUMN = -2
    ERR_BADFILENAME = -3

    def __init__(self, filename=None, logger=None, score=0):
        if logger is None:
            self.logger = LOGGER.getChild(self.__class__.__name__)
        self.filename = filename
        self.score = score
        self.cvedb = CVEDB()
        self.cve_scanner = CVEScanner()

    def db_update(self, update):

        # Clear data if -u now is set
        if update == "now":
            self.cvedb.clear_cached_data()

        # update data to the latest available data
        if update == "latest":
            self.cvedb.refresh_cache_and_update_db()

        # skip the database update
        if update != "never":
            self.cvedb.get_cvelist_if_stale()
        else:
            LOGGER.warning("Not verifying CVE DB cache")
            if not self.cvedb.nvd_years():
                raise EmptyCache(self.cvedb.cachedir)

    def update_logLevel(self, log_level):
        if log_level:
            self.logger.setLevel(log_level)

    def get_cves(self):
        """Summary: Returns Dictionary containing Product_Name, Version,
        CVE_Number and Severity associated with each module

        Returns:
        Example --> [
            (
                vendor name",
                product name",
                "x.x.x",
                [
                    ("cve-xxxx-xxx", "high"),
                    ("cve-xxxx-xxx", "low"),
                ]
            ), ...
        ]
        """

        self.logger.debug(f"Opening File: {self.filename}")

        # we will try opening the file. If unsuccessful, Raise FileNotFound.
        try:
            with open(self.filename) as csvfile:
                csvdata = csv.DictReader(
                    csvfile, delimiter=","
                )  # "," is default anyhow

                if csvdata is None or csvdata.fieldnames is None:
                    self.logger.error("Error: invalid CSV")
                    return self.ERR_BADCSV

                required_columns = {"vendor", "product", "version"}
                csv_columns = set(csvdata.fieldnames)
                missing_columns = required_columns - csv_columns
                if missing_columns != set():
                    self.logger.error(f"Error: no {missing_columns} columns found")
                    return self.ERR_MISSINGCOLUMN

                all_cves = []

                # Go row by row and look for CVEs
                for row in csvdata:
                    cves = self.cve_scanner.get_cves(
                        row["vendor"], row["product"], row["version"], self.score
                    )

                    if cves:
                        self.logger.debug(
                            f'Found CVES for {row["vendor"]} {row["product"]}, version {row["version"]}'
                        )
                        # if we found CVES add to the all_cves
                        cve_data = CVEData(
                            row["vendor"], row["product"], row["version"], cves
                        )
                        if cve_data not in all_cves:
                            all_cves.append(cve_data)

                    else:
                        self.logger.debug(
                            f'No CVEs found for {row["vendor"]} {row["product"]}, version {row["version"]}. Is the vendor/product info correct?'
                        )
                        # Vendor Product is wrong mark CVE_Number and Severity = UNKNOWN
                        all_cves.append(
                            CVEData(
                                row["vendor"],
                                row["product"],
                                row["version"],
                                [CVE("UNKNOWN", "UNKNOWN"),],
                            )
                        )

                return all_cves

        except Exception as error:
            self.logger.error(error)
            return self.ERR_BADFILENAME

    def generate_output(self, outfile, format):
        """generates the output from output engine"""

        # all_cves will either contain list of CVEData or negative number
        all_cves = self.get_cves()
        try:
            # check if all_cves contain number or empty list
            if (all_cves < 0) or not all_cves:
                return all_cves
        except Exception:
            self.output_engine = OutputEngine(
                filename=outfile, products=all_cves, logger=self.logger
            )
            self.output_engine.output_file(format)


def main(argv=None):
    """ Take a list of product information + versions from a CSV file,
    and output a list of matching CVES """

    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser(
        prog="csv2cve",
        description="This tool takes a list of software + versions from a CSV file \
        and outputs a list of CVEs known to affect those versions",
    )
    parser.add_argument(
        "csv_file",
        action="store",
        help="CSV file with product data. Must contain vendor,product,version, \
        where vendor and product match entries in the National Vulnerability Database.",
    )
    output_group = parser.add_argument_group("Output")
    output_group.add_argument(
        "-l",
        "--log",
        help="log level (default: info)",
        dest="log_level",
        action=LogAction,
        choices=["debug", "info", "warning", "error", "critical"],
    )
    output_group.add_argument(
        "-o",
        "--output-file",
        action="store",
        default=None,
        help="provide output filename (default: output to stdout)",
    )
    output_group.add_argument(
        "-c",
        "--cvss",
        action="store",
        default=0,
        help="minimum CVSS score (as integer in range 0 to 10) to report (default: 0)",
    )
    output_group.add_argument(
        "-S",
        "--severity",
        action="store",
        choices=["low", "medium", "high", "critical"],
        default="low",
        help="minimum CVE severity to report (default: low)",
    )
    output_group.add_argument(
        "-f",
        "--format",
        action="store",
        choices=["csv", "json", "console"],
        default="console",
        help="update output format (default: console)",
    )
    output_group.add_argument(
        "-q", "--quiet", action="store_true", help="suppress output"
    )
    parser.add_argument(
        "-u",
        "--update",
        action="store",
        choices=["now", "daily", "never", "latest"],
        default="daily",
        help="update schedule for NVD database (default: daily)",
    )

    if len(argv) <= 1:
        parser.print_help()
        return 0

    args = parser.parse_args(argv[1:])
    if int(args.cvss) > 0:
        score = int(args.cvss)
    elif args.severity:
        # Set minimum CVSS score based on severity
        cvss_score = {"low": 0, "medium": 4, "high": 7, "critical": 9}
        score = cvss_score[args.severity]
    else:
        score = 0

    # Create a CSV2CVE object
    csv2cve = CSV2CVE(filename=args.csv_file, score=score)
    csv2cve.db_update(update=args.update)
    if args.quiet:
        csv2cve.update_logLevel(log_level=logging.CRITICAL)
    else:
        csv2cve.update_logLevel(log_level=args.log_level)
    csv2cve.generate_output(args.output_file, args.format)


if __name__ == "__main__":
    sys.exit(main())
