#!/usr/bin/python3
from __future__ import print_function

import argparse
import csv
import sys
import logging

from collections import defaultdict
from .cvedb import CVEDB
from .cli import LogAction
from .log import LOGGER
from .OutputEngine import OutputEngine
from .scanner import CVEData
from .scanner import CVE


class CSV2CVE(object):
    """Generate CVE Output from a CSV file """

    ERR_BADCSV = -1
    ERR_MISSINGCOLUMN = -2
    ERR_BADFILENAME = -3

    def __init__(self, filename=None, logger=None, score=0):
        if logger is None:
            self.logger = LOGGER.getChild(self.__class__.__name__)
        self.filename = filename
        self.score = score
        self.cvedb = CVEDB()

    def db_update(self, update):

        # Clear data if -u now is set
        if update == "now":
            self.cvedb.clear_cached_data()

        # update data to the latest available data
        if update == "latest":
            self.cvedb.refresh_cache_and_update_db()

        # skip the database update
        if update != "never":
            self.cvedb.get_cvelist_if_stale()

    def update_logLevel(self, log_level):
        if log_level:
            self.logger.setLevel(log_level)

    def get_cves(self):
        """Summary: Returns Dictionary containing Product_Name, Version,
        CVE_Number and Severity associated with each module

        Returns:
        Example --> [
            (
                vendor name",
                product name",
                "x.x.x",
                [
                    ("cve-xxxx-xxx", "high"),
                    ("cve-xxxx-xxx", "low"),
                ]
            ), ...
        ]
        """

        self.logger.debug(f"Opening File: {self.filename}")

        # we will try opening the file. If unsuccessful, Raise FileNotFound.
        try:
            with open(self.filename) as csvfile:
                csvdata = csv.DictReader(
                    csvfile, delimiter=","
                )  # "," is default anyhow

                if csvdata is None or csvdata.fieldnames is None:
                    self.logger.error("Error: invalid CSV")
                    return self.ERR_BADCSV

                required_columns = {"vendor", "product", "version"}
                csv_columns = set(csvdata.fieldnames)
                missing_columns = required_columns - csv_columns
                if missing_columns != set():
                    self.logger.error(f"Error: no {missing_columns} columns found")
                    return self.ERR_MISSINGCOLUMN

                all_cves = []

                # Go row by row and look for CVEs
                for row in csvdata:
                    cves = self.cvedb.get_cves(
                        row["vendor"], row["product"], row["version"], self.score
                    )

                    if cves:
                        self.logger.debug(
                            f'Found CVES for {row["vendor"]} {row["product"]}, version {row["version"]}'
                        )
                        # if we found CVES add to the all_cves
                        cve_data = CVEData(
                            row["vendor"], row["product"], row["version"], cves
                        )
                        if cve_data not in all_cves:
                            all_cves.append(cve_data)

                    else:
                        self.logger.debug(
                            f'No CVEs found for {row["vendor"]} {row["product"]}, version {row["version"]}. Is the vendor/product info correct?'
                        )
                        # Vendor Product is wrong mark CVE_Number and Severity = UNKNOWN
                        all_cves.append(
                            CVEData(
                                row["vendor"],
                                row["product"],
                                row["version"],
                                cves=[CVE("UNKNOWN", "UNKNOWN"),],
                            )
                        )

                # close down the NVD database
                self.cvedb.close()

                return all_cves

        except Exception as E:
            self.logger.error(E)
            return self.ERR_BADFILENAME

    def generate_output(self, outfile, format):
        """generates the output from output engine"""

        # all_cves will either contain list of CVEData or negative number
        all_cves = self.get_cves()
        try:
            # check if all_cves contain number or None
            if (all_cves < 0) or all_cves is None:
                return all_cves
        except Exception:
            self.output_engine = OutputEngine(
                filename=outfile, all_cves=all_cves, logger=self.logger
            )
            self.output_engine.output_file(format)


def main(argv=None, outfile=None):
    """ Take a list of product information + versions from a CSV file,
    and output a list of matching CVES """

    if argv is None:
        argv = sys.argv

    if outfile is None:
        outfile = sys.stdout

    parser = argparse.ArgumentParser(
        prog="csv2cve",
        description="This tool takes a list of software + versions from a CSV file \
        and outputs a list of CVEs known to affect those versions",
    )
    parser.add_argument(
        "csv_file",
        action="store",
        help="CSV file with product data. Must contain vendor,product,version, \
        where vendor and product match entries in the National Vulnerability Database.",
    )
    output_group = parser.add_argument_group("Output")
    output_group.add_argument(
        "-l",
        "--log",
        help="log level (default: info)",
        dest="log_level",
        action=LogAction,
        choices=["debug", "info", "warning", "error", "critical"],
    )
    output_group.add_argument(
        "-o",
        "--output-file",
        action="store",
        default=sys.stdout,
        help="provide output filename (default: output to stdout)",
    )
    output_group.add_argument(
        "-c",
        "--cvss",
        action="store",
        default=0,
        help="minimum CVSS score (as integer in range 0 to 10) to report (default: 0)",
    )
    output_group.add_argument(
        "-S",
        "--severity",
        action="store",
        choices=["low", "medium", "high", "critical"],
        default="low",
        help="minimum CVE severity to report (default: low)",
    )
    output_group.add_argument(
        "-f",
        "--format",
        action="store",
        choices=["csv", "json", "console"],
        default="console",
        help="update output format (default: console)",
    )
    output_group.add_argument(
        "-q", "--quiet", action="store_true", help="suppress output"
    )
    parser.add_argument(
        "-u",
        "--update",
        action="store",
        choices=["now", "daily", "never", "latest"],
        default="daily",
        help="update schedule for NVD database (default: daily)",
    )

    if len(argv) <= 1:
        parser.print_help()
        return 0

    args = parser.parse_args(argv[1:])
    if int(args.cvss) > 0:
        score = int(args.cvss)
    elif args.severity:
        # Set minimum CVSS score based on severity
        cvss_score = {"low": 0, "medium": 4, "high": 7, "critical": 9}
        score = cvss_score[args.severity]
    else:
        score = 0

    # Create a CSV2CVE object
    csv2cve = CSV2CVE(filename=args.csv_file, score=score)
    csv2cve.db_update(update=args.update)
    if args.quiet:
        csv2cve.update_logLevel(log_level=logging.CRITICAL)
    else:
        csv2cve.update_logLevel(log_level=args.log_level)
    csv2cve.generate_output(args.output_file, args.format)


if __name__ == "__main__":
    sys.exit(main())
