import os
import subprocess
import sys
from collections import defaultdict

import pkg_resources

from .egg_updater import IS_DEVELOP, update_egg
from .extractor import Extractor
from .file import is_binary
from .log import LOGGER
from .strings import Strings
from .util import inpath, DirWalk


class InvalidFileError(Exception):
    """ Filepath is invalid for scanning."""


class Scanner(object):
    """"Scans files for CVEs using CVE checkers"""

    CHECKER_ENTRYPOINT = "cve_bin_tool.checker"

    def __init__(self, cvedb, should_extract=False, checkers=None, logger=None):
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        # Update egg if installed in development mode
        if IS_DEVELOP():
            logger.info("Updating egg_info")
            update_egg()

        # Load checkers if not given
        if checkers is None:
            checkers = self.load_checkers()
        self.cvedb = cvedb
        self.checkers = checkers
        self.logger = logger
        self.all_cves = defaultdict(dict)
        self.files_with_cve = 0
        exclude_folders = [".git"]
        self.walker = DirWalk(folder_exclude_pattern=";".join(exclude_folders)).walk
        self.should_extract = should_extract
        # self.logger.info("Checkers loaded: %s" % (", ".join(self.checkers.keys())))

    @classmethod
    def load_checkers(cls):
        """ Loads CVE checkers """
        checkers = dict(
            map(
                lambda checker: (checker.name, checker.load()),
                pkg_resources.iter_entry_points(cls.CHECKER_ENTRYPOINT),
            )
        )
        return checkers

    @classmethod
    def available_checkers(cls):
        checkers = pkg_resources.iter_entry_points(cls.CHECKER_ENTRYPOINT)
        checker_list = [item.name for item in checkers]
        return checker_list

    def remove_skiplist(self, skips=None):
        # Take out any checkers that are on the skip list
        # (string of comma-delimited checker names)
        skiplist = skips.split(",") if skips else []
        for skipme in skiplist:
            if skipme in self.checkers:
                del self.checkers[skipme]
                self.logger.debug(f"Skipping checker: {skipme}")
            else:
                self.logger.error(f"Checker {skipme} is not a valid checker name")

    def print_checkers(self):
        self.logger.info(f'Checkers: {", ".join(self.checkers.keys())}')

    def get_cves(self, vendor_package_pairs, vers):
        """Returns a list of cves affecting a given version of a piece of software
        """
        cves = dict()

        # get all cves for each vendor_package_pair
        for vendor, package in vendor_package_pairs:
            cves.update(self.cvedb.get_cves(vendor, package, vers))

        return cves

    def scan_file(self, filename):
        """Scans a file to see if it contains any of the target libraries,
        and whether any of those contain CVEs"""

        self.logger.debug(f"Scanning file: {filename}")

        # Do not try to scan symlinks
        if os.path.islink(filename):
            return None

        # Ensure filename is a file
        if not os.path.isfile(filename):
            raise InvalidFileError(filename)

        # step 1: check if it's an ELF binary file
        if inpath("file"):
            # use system file if available (for performance reasons)
            o = subprocess.check_output(["file", filename])
            o = o.decode(sys.stdout.encoding)

            if "cannot open" in o:
                raise InvalidFileError(filename)

            if (
                ("LSB " not in o)
                and ("LSB shared" not in o)
                and ("LSB executable" not in o)
                and ("PE32 executable" not in o)
                and ("PE32+ executable" not in o)
                and ("Mach-O" not in o)
            ):
                return None
        # otherwise use python implementation of file
        elif not is_binary(filename):
            return None
        # parse binary file's strings
        if inpath("strings"):
            # use "strings" on system if available (for performance)
            o = subprocess.check_output(["strings", filename])
            lines = o.decode("utf-8").splitlines()
        else:
            # Otherwise, use python implementation
            s = Strings(filename)
            lines = s.parse()
        print(lines)
        # tko
        for (dummy_checker_name, checker,) in self.checkers.items():
            checker = checker()
            result = checker.get_version(lines, filename)
            # do some magic so we can iterate over all results, even the ones that just return 1 hit
            if "is_or_contains" in result:
                results = [dict()]
                results[0] = result
            else:
                results = result

            for result in results:
                if "is_or_contains" in result:
                    modulename = result["modulename"]
                    version = "UNKNOWN"
                    if "version" in result and result["version"] != "UNKNOWN":
                        version = result["version"]
                    elif result["version"] == "UNKNOWN":
                        self.logger.warning(
                            f"{modulename} was detected with version UNKNOWN in file {filename}"
                        )
                    else:
                        self.logger.error(f"No version info for {modulename}")

                    if version != "UNKNOWN":
                        found_cves = self.get_cves(checker.VENDOR_PACKAGE, version)
                        if found_cves:
                            self.files_with_cve = self.files_with_cve + 1
                        self.all_cves[modulename][version] = found_cves
                        self.logger.info(
                            f'{filename} {result["is_or_contains"]} {modulename} {version}'
                        )
                        if found_cves.keys():
                            self.logger.info(f"Known CVEs in version {version}")
                            self.logger.info(", ".join(found_cves.keys()))

        self.logger.debug(f"Done scanning file: {filename}")
        return self.all_cves

    def scan_and_or_extract_file(self, ectx, filepath):
        """ Runs extraction if possible and desired otherwise scans."""
        # Scan the file
        self.scan_file(filepath)
        # Attempt to extract the file and scan the contents
        if ectx.can_extract(filepath):
            if not self.should_extract:
                LOGGER.warning(
                    f"{filepath} is an archive. Pass -x option to auto-extract"
                )
                return
            for filename in self.walker([ectx.extract(filepath)]):
                self.scan_and_or_extract_file(ectx, filename)

    def recursive_scan(self, scan_path):
        with Extractor()() as ectx:
            if os.path.isdir(scan_path):
                for filepath in self.walker([scan_path]):
                    self.scan_and_or_extract_file(ectx, filepath)
            elif os.path.isfile(scan_path):
                self.scan_and_or_extract_file(ectx, scan_path)

    def affected(self):
        """ Returns list of module name and version tuples identified from
        scan"""
        return [
            (modulename, version)
            for modulename, versions in self.all_cves.items()
            for version in versions.keys()
        ]
