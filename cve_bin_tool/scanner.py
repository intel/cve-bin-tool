import os
import subprocess
import sys
from collections import defaultdict

import pkg_resources

from .egg_updater import IS_DEVELOP, update_egg
from .extractor import Extractor
from .file import is_binary
from .log import LOGGER
from .strings import Strings
from .util import inpath, DirWalk

from typing import NamedTuple, List


class CVE(NamedTuple):
    cve_id: str
    severity: str
    description: str = ""


class CVEData(NamedTuple):
    vendor: str
    product: str
    checker: str = ""
    version: str
    cves: List[CVE]


class InvalidFileError(Exception):
    """ Filepath is invalid for scanning."""


class Scanner(object):
    """"Scans files for CVEs using CVE checkers"""

    CHECKER_ENTRYPOINT = "cve_bin_tool.checker"

    def __init__(
        self, cvedb, should_extract=False, checkers=None, logger=None, score=0
    ):
        if logger is None:
            logger = LOGGER.getChild(self.__class__.__name__)
        # Update egg if installed in development mode
        if IS_DEVELOP():
            logger.info("Updating egg_info")
            update_egg()

        # Load checkers if not given
        if checkers is None:
            checkers = self.load_checkers()
        self.cvedb = cvedb
        self.checkers = checkers
        self.logger = logger
        self.all_cves = []
        self.files_with_cve = 0
        self.total_scanned_files = 0
        self.files_without_cve = 0
        exclude_folders = [".git"]
        self.walker = DirWalk(folder_exclude_pattern=";".join(exclude_folders)).walk
        self.should_extract = should_extract
        # self.logger.info("Checkers loaded: %s" % (", ".join(self.checkers.keys())))

    @classmethod
    def load_checkers(cls):
        """ Loads CVE checkers """
        checkers = dict(
            map(
                lambda checker: (checker.name, checker.load()),
                pkg_resources.iter_entry_points(cls.CHECKER_ENTRYPOINT),
            )
        )
        return checkers

    @classmethod
    def available_checkers(cls):
        checkers = pkg_resources.iter_entry_points(cls.CHECKER_ENTRYPOINT)
        checker_list = [item.name for item in checkers]
        return checker_list

    def remove_skiplist(self, skips=None):
        # Take out any checkers that are on the skip list
        # (string of comma-delimited checker names)
        skiplist = skips.split(",") if skips else []
        for skipme in skiplist:
            if skipme in self.checkers:
                del self.checkers[skipme]
                self.logger.debug(f"Skipping checker: {skipme}")
            else:
                self.logger.error(f"Checker {skipme} is not a valid checker name")

    def print_checkers(self):
        self.logger.info(f'Checkers: {", ".join(self.checkers.keys())}')

    def get_cves(self, vendor_product_pairs, version, checker):
        """Returns a list of cves affecting a given version of a piece of software
        """
        # get all cves for each vendor_package_pair
        for vendor, product in vendor_product_pairs:
            cves = self.cvedb.get_cves(vendor, product, version)
            cve_data = CVEData(vendor, product, checker, version, cves)
            if cves:
                self.files_with_cve += 1
                self.logger.info(f"Known CVEs in version {version}")
                self.logger.info(", ".join([cve.cve_id for cve in cves]))
            else:
                self.files_without_cve += 1
            if cve_data not in self.all_cves:
                self.all_cves.append(cve_data)

    def scan_file(self, filename):
        """Scans a file to see if it contains any of the target libraries,
        and whether any of those contain CVEs"""

        self.logger.debug(f"Scanning file: {filename}")
        self.total_scanned_files += 1

        # Do not try to scan symlinks
        if os.path.islink(filename):
            return None

        # Ensure filename is a file
        if not os.path.isfile(filename):
            raise InvalidFileError(filename)

        # step 1: check if it's an ELF binary file
        if inpath("file"):
            # use system file if available (for performance reasons)
            o = subprocess.check_output(["file", filename])
            o = o.decode(sys.stdout.encoding)

            if "cannot open" in o:
                raise InvalidFileError(filename)

            if (
                ("LSB " not in o)
                and ("LSB shared" not in o)
                and ("LSB executable" not in o)
                and ("PE32 executable" not in o)
                and ("PE32+ executable" not in o)
                and ("Mach-O" not in o)
            ):
                return None
        # otherwise use python implementation of file
        elif not is_binary(filename):
            return None
        # parse binary file's strings
        if inpath("strings"):
            # use "strings" on system if available (for performance)
            o = subprocess.check_output(["strings", filename])
            lines = o.decode("utf-8").splitlines()
        else:
            # Otherwise, use python implementation
            s = Strings(filename)
            lines = s.parse()

        # tko
        for (dummy_checker_name, checker) in self.checkers.items():
            checker = checker()
            result = checker.get_version(lines, filename)
            # do some magic so we can iterate over all results, even the ones that just return 1 hit
            if "is_or_contains" in result:
                results = [dict()]
                results[0] = result
            else:
                results = result

            for result in results:
                if "is_or_contains" in result:
                    version = "UNKNOWN"
                    if "version" in result and result["version"] != "UNKNOWN":
                        version = result["version"]
                    elif result["version"] == "UNKNOWN":
                        self.logger.warning(
                            f"{dummy_checker_name} was detected with version UNKNOWN in file {filename}"
                        )
                    else:
                        self.logger.error(f"No version info for {dummy_checker_name}")

                    if version != "UNKNOWN":
                        self.logger.info(
                            f'{filename} {result["is_or_contains"]} {dummy_checker_name} {version}'
                        )
                        self.get_cves(
                            checker.VENDOR_PACKAGE, version, dummy_checker_name
                        )

        self.logger.debug(f"Done scanning file: {filename}")
        return self.all_cves

    def scan_and_or_extract_file(self, ectx, filepath):
        """ Runs extraction if possible and desired otherwise scans."""
        # Scan the file
        self.scan_file(filepath)
        # Attempt to extract the file and scan the contents
        if ectx.can_extract(filepath):
            if not self.should_extract:
                LOGGER.warning(
                    f"{filepath} is an archive. Pass -x option to auto-extract"
                )
                return
            for filename in self.walker([ectx.extract(filepath)]):
                self.scan_and_or_extract_file(ectx, filename)

    def recursive_scan(self, scan_path):
        with Extractor()() as ectx:
            if os.path.isdir(scan_path):
                for filepath in self.walker([scan_path]):
                    self.scan_and_or_extract_file(ectx, filepath)
            elif os.path.isfile(scan_path):
                self.scan_and_or_extract_file(ectx, scan_path)

    def affected(self):
        """ Returns list of module name and version tuples identified from
        scan"""
        return [(cve_data.product, cve_data.version) for cve_data in self.all_cves]
