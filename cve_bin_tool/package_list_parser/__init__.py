# Copyright (C) 2021 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import csv
import json
import re
import subprocess
from collections import defaultdict
from logging import Logger
from os.path import dirname, getsize, isfile, join

from cve_bin_tool.error_handler import (
    EmptyTxtError,
    ErrorHandler,
    ErrorMode,
    NotTxtError,
)
from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import ProductInfo, ProductInfoWithoutVendor, Remarks

ROOT_PATH = join(dirname(__file__), "..")
PYPI_CSV = join(ROOT_PATH, "package_list_parser", "pypi_list.csv")


class PackageListParser:
    def __init__(
        self, input_file: str, logger: Logger = None, error_mode=ErrorMode.TruncTrace
    ) -> None:
        self.input_file = input_file
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.error_mode = error_mode
        self.parsed_data_without_vendor = defaultdict(dict)
        self.parsed_data_with_vendor = defaultdict(dict)

    def parse_list(self):
        self.check_file()

        txt_package_names = []
        csv_package_names = []
        csv_package_vendors = []
        package_names_with_vendor = []
        package_names_without_vendor = []

        installed_packages_json = subprocess.run(
            ["pip", "list", "--format", "json"],
            stdout=subprocess.PIPE,
        )
        installed_packages = json.loads(
            str(installed_packages_json.stdout)[2:-1].split("\\n")[0]
        )

        with open(PYPI_CSV) as csvfile, open(self.input_file) as txtfile:
            csv_reader = csv.reader(csvfile)
            next(csv_reader)
            lines = txtfile.readlines()

            for line in lines:
                txt_package_names.append(re.split(">|\\[|;|=|\n", line)[0])
            for (vendor, product) in csv_reader:
                csv_package_names.append(product)
                csv_package_vendors.append(vendor)
            for installed_package in installed_packages:
                package_name = installed_package["name"].lower()
                if package_name in txt_package_names:
                    if package_name in csv_package_names:
                        installed_package["vendor"] = csv_package_vendors[
                            csv_package_names.index(package_name)
                        ]
                        package_names_with_vendor.append(installed_package)
                    else:
                        package_names_without_vendor.append(installed_package)

            not_found_package_names = set(txt_package_names) - set(csv_package_names)
            LOGGER.warning(
                f"{not_found_package_names} are not found in the mapping. Please provide mappings for them if possible."
            )

            self.parse_data_with_vendor(package_names_with_vendor)
            self.parse_data_without_vendor(package_names_without_vendor)
            return [self.parsed_data_with_vendor, self.parsed_data_without_vendor]

    def parse_data_with_vendor(self, data):
        for row in data:
            product_info = ProductInfo(
                row["vendor"], row["name"].lower(), row["version"]
            )
            self.parsed_data_with_vendor[product_info][
                row.get("cve_number", "").strip() or "default"
            ] = {
                "remarks": Remarks(str(row.get("remarks", "")).strip()),
                "comments": row.get("comments", "").strip(),
                "severity": row.get("severity", "").strip(),
            }
            self.parsed_data_with_vendor[product_info]["paths"] = {""}

    def parse_data_without_vendor(self, data):
        for row in data:
            product_info = ProductInfoWithoutVendor(row["name"].lower(), row["version"])
            self.parsed_data_without_vendor[product_info][
                row.get("cve_number", "").strip() or "default"
            ] = {
                "remarks": Remarks(str(row.get("remarks", "")).strip()),
                "comments": row.get("comments", "").strip(),
                "severity": row.get("severity", "").strip(),
            }
            self.parsed_data_without_vendor[product_info]["paths"] = {""}

    def check_file(self):
        input_file = self.input_file
        error_mode = self.error_mode

        if not isfile(input_file):
            with ErrorHandler(mode=error_mode):
                raise FileNotFoundError(input_file)

        if not input_file.endswith(".txt"):
            with ErrorHandler(mode=error_mode):
                raise NotTxtError(input_file)

        if getsize(input_file) == 0:
            with ErrorHandler(mode=error_mode):
                raise EmptyTxtError(input_file)
