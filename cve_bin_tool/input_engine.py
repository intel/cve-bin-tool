# Copyright (C) 2021 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

"""
Module: input_engine.py

This module provides the InputEngine class for parsing different input file formats in the CVE Bin Tool.

"""

import csv
import json
import re
from collections import defaultdict
from logging import Logger
from pathlib import Path
from typing import Any, DefaultDict, Dict, Iterable, Set, Union

from cve_bin_tool.cvedb import CVEDB
from cve_bin_tool.error_handler import (
    ErrorHandler,
    ErrorMode,
    InvalidCsvError,
    InvalidJsonError,
    MissingFieldsError,
)
from cve_bin_tool.log import LOGGER
from cve_bin_tool.util import ProductInfo, Remarks

# TriageData is dictionary of cve_number mapped to dictionary of remarks, comments and custom severity
TriageData = Dict[str, Union[Dict[str, Any], Set[str]]]


class InputEngine:
    """
    Class: InputEngine

    This class is responsible for parsing various input file formats (CSV, VEX, JSON) in the CVE Bin Tool.

    Attributes:
    - parsed_data (DefaultDict[ProductInfo, TriageData]): Dictionary containing parsed input data.

    Methods:
    - __init__(self, filename: str, logger: Logger = None, error_mode=ErrorMode.TruncTrace, filetype="autodetect"):
        Initializes the InputEngine with the specified filename, logger, error mode, and filetype.

    - parse_input(self) -> DefaultDict[ProductInfo, TriageData]:
        Parses the input file based on its type (CSV, VEX, JSON) and returns the parsed data.

    - input_csv(self) -> None:
        Parses input data from a CSV file.

    - input_json(self) -> None:
        Parses input data from a JSON file.

    - input_vex(self) -> None:
        Parses input data from a CycloneDX VEX file.

    - validate_product(self, product: str) -> bool:
        Validates if a product name conforms to the CPE 2.3 standard.

    - input_vex(self) -> None:
        Parses input data from a CycloneDX VEX file.

    - parse_data(self, fields: Set[str], data: Iterable) -> None:
        Parses common data structure for CSV and JSON input formats.

    """

    # parsed_data is a dictionary of vendor, product, version mapped to TriageData
    parsed_data: DefaultDict[ProductInfo, TriageData]

    def __init__(
        self,
        filename: str,
        logger: Logger = None,
        error_mode=ErrorMode.TruncTrace,
        filetype="autodetect",
    ):
        """
        Initializes the InputEngine instance.

        Args:
        - filename (str): Path to the input file.
        - logger (Logger, optional): Logger instance for logging messages.
        - error_mode (ErrorMode, optional): Error handling mode.
        - filetype (str, optional): Type of the input file (default is "autodetect").

        """
        self.filename = str(Path(filename).resolve())
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.error_mode = error_mode
        self.filetype = filetype
        self.parsed_data = defaultdict(dict)
        # Connect to the database
        self.cvedb = CVEDB(version_check=False)

    def parse_input(self) -> DefaultDict[ProductInfo, TriageData]:
        """
        Parses the input file and returns the parsed data.

        Returns:
        - DefaultDict[ProductInfo, TriageData]: Parsed input data.

        """
        if not Path(self.filename).is_file():
            with ErrorHandler(mode=self.error_mode):
                raise FileNotFoundError(self.filename)
        if self.filename.endswith(".csv"):
            self.input_csv()
        elif self.filename.endswith(".vex") or self.filetype == "vex":
            self.input_vex()
        elif self.filename.endswith(".json"):
            self.input_json()
        return self.parsed_data

    def input_csv(self) -> None:
        """
        Parses input data from a CSV file.

        Raises:
        - InvalidCsvError: If the CSV file is invalid.

        """
        with open(self.filename) as csv_file:
            csvdata = csv.DictReader(csv_file)
            if csvdata is None or csvdata.fieldnames is None:
                with ErrorHandler(mode=self.error_mode):
                    raise InvalidCsvError(self.filename)

            self.parse_data(set(csvdata.fieldnames), csvdata)

    def input_json(self) -> None:
        """
        Parses input data from a JSON file.

        Raises:
        - InvalidJsonError: If the JSON file is invalid.

        """
        with open(self.filename) as json_file:
            json_data = json.load(json_file)
            if not json_data or not isinstance(json_data, list):
                with ErrorHandler(mode=self.error_mode):
                    raise InvalidJsonError(self.filename)

            self.parse_data(set(json_data[0].keys()), json_data)

    def validate_product(self, product: str) -> bool:
        """
        Validates if a product name conforms to the CPE 2.3 standard.

        Args:
        - product (str): Product name.

        Returns:
        - bool: True if the product name is valid, False otherwise.

        """
        """
        Ensure product name conforms to CPE 2.3 standard.
        See https://csrc.nist.gov/schema/cpe/2.3/cpe-naming_2.3.xsd for naming specification
        """
        cpe_regex = r"\A([A-Za-z0-9\._\-~ %])+\Z"
        return re.search(cpe_regex, product) is not None

    def input_vex(self) -> None:
        """
        Parses input data from a CycloneDX VEX file.

        """

        def strip_remark(detail) -> str:
            detail = re.sub("^" + Remarks.NewFound.name + "(: )?", "", detail)
            detail = re.sub("^" + Remarks.Unexplored.name + "(: )?", "", detail)
            detail = re.sub("^" + Remarks.Confirmed.name + "(: )?", "", detail)
            detail = re.sub("^" + Remarks.Mitigated.name + "(: )?", "", detail)
            detail = re.sub("^" + Remarks.FalsePositive.name + "(: )?", "", detail)
            detail = re.sub("^" + Remarks.NotAffected.name + "(: )?", "", detail)
            return detail

        # Map CycloneDX v1.4 anaylsis state to the Remarks enumeration.
        analysis_state = {
            "resolved": Remarks.Mitigated,
            "resolved_with_pedigree": Remarks.Mitigated,
            "exploitable": Remarks.Confirmed,
            "in_triage": Remarks.Unexplored,
            "false_positive": Remarks.FalsePositive,
            "not_affected": Remarks.NotAffected,
        }
        with open(self.filename) as json_file:
            json_data = json.load(json_file)
            # Only handle CycloneDX VEX file format
            if json_data["bomFormat"] == "CycloneDX":
                # Not all data from the BOM needs to be read because it will be updated from the
                # CVE DB. Read the analysis fields that may have been updated manually.
                for vulnerability in json_data["vulnerabilities"]:
                    id = vulnerability["id"]
                    analysis_status = vulnerability["analysis"]["state"].lower()
                    state = Remarks.Unexplored
                    if analysis_status in analysis_state:
                        state = analysis_state[analysis_status]
                    justification = vulnerability["analysis"].get("justification", None)
                    response = vulnerability["analysis"]["response"]
                    comments = strip_remark(vulnerability["analysis"]["detail"])
                    severity = None
                    if "ratings" in vulnerability:
                        for rating in vulnerability["ratings"]:
                            severity = rating["severity"].upper()
                    for affect in vulnerability["affects"]:
                        ref = affect["ref"]
                        version = None
                        vendor = None
                        # Expected ref format is urn:cbt:{bom_version}/{vendor}#{product}-{version}
                        if "#" in ref:
                            # Extract product information after # delimiter
                            p = ref.split("#")[1]
                            # Last element is version, rest is product which may include -
                            elements = p.rsplit("-", 1)
                            product = elements[0]
                            version = elements[1]
                            # Note that cbt (cve-bin-tool) and cdx (cyclonedx)
                            # namespaces are different

                            vendor_match = None
                            if re.match("urn:cbt", ref):
                                # cbt looks like "urn:cbt:1/gnu#glibc-2.33"
                                # vendor is between / and #
                                vendor_match = re.match("urn:cbt:[^/]*/([^#]*)#", ref)
                            # cdx looks like "urn:cdx:NOTKNOWN/1#libjpeg-turbo-2.0.1"
                            # There is no vendor so we fall through

                            if vendor_match is not None:
                                vendor = vendor_match.group(1)
                            else:
                                vendor = "UNKNOWN"

                        if version is not None and self.validate_product(product):
                            product_info = ProductInfo(
                                vendor.strip(), product.strip(), version.strip()
                            )
                            self.parsed_data[product_info][id.strip() or "default"] = {
                                "remarks": state,
                                "comments": comments.strip(),
                                "response": response,
                            }
                            if justification:
                                self.parsed_data[product_info][id.strip() or "default"][
                                    "justification"
                                ] = justification.strip()
                            if severity:
                                self.parsed_data[product_info][id.strip() or "default"][
                                    "severity"
                                ] = severity.strip()
                            self.parsed_data[product_info]["paths"] = {}

    def parse_data(self, fields: Set[str], data: Iterable) -> None:
        """
        Parses common data structure for CSV and JSON input formats.

        Args:
        - fields (Set[str]): Set of fields present in the input data.
        - data (Iterable): Iterable containing the input data.

        Raises:
        - MissingFieldsError: If required fields are missing in the input data.

        """
        required_fields = {"vendor", "product", "version"}
        missing_fields = required_fields - fields
        if missing_fields != set():
            with ErrorHandler(mode=self.error_mode):
                raise MissingFieldsError(f"{missing_fields} are required fields")

        for row in data:
            product_info = ProductInfo(
                row["vendor"].strip(), row["product"].strip(), row["version"].strip()
            )
            self.parsed_data[product_info][
                row.get("cve_number", "").strip() or "default"
            ] = {
                "remarks": Remarks(str(row.get("remarks", "")).strip()),
                "comments": row.get("comments", "").strip(),
                "severity": row.get("severity", "").strip(),
            }
            self.parsed_data[product_info]["paths"] = set(
                map(lambda x: x.strip(), row.get("paths", "").split(","))
            )
