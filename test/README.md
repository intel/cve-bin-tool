# cve-bin-tool tests

## Running all tests

To run the tests for `cve-bin-tool`

```console
python setup.py test
```

By default, some longer-running tests are turned off.  If you want to enable them, you can set the environment variable LONG_TESTS to 1.  You can do this just for a single command line as follows:

```console
LONG_TESTS=1 python setup.py test
```


## Running a single test

To run a single test, you can use the unittest framework.  For example, here's how to run
the test for sqlite:

```console
python -m unittest test.test_scanner.TestScanner.test_sqlite_3_12_2
```

## Running tests on different versions of Python

Our CI currently runs tests on Python 3.6 and 3.7 under Linux.

The recommended way to do this yourself is to use python's `virtualenv`

You can set up virtualenv for all these environments:

```console
virtualenv -p python3.6 venv3.6
virtualenv -p python3.7 venv3.7
```

To activate one of these (the example uses 3.6), run the tests, and deactivate:

```console
source venv3.6/bin/activate
python setup.py test
deactivate

```

## Adding new tests: CVE mapping tests

* Existing tests are in [`test/`](https://github.com/intel/cve-bin-tool/tree/master/test)
* You can see the scanner tests in ['tests/test_scanner.py'](https://github.com/intel/cve-bin-tool/blob/master/test/test_scanner.py)
* To add a new one, make a new test case that detects a few CVEs known to occur in this version, and a few that are known not to occur in that version.  For example, here's what the current openssl test looks like:
```
    def test_openssl_1_0_2g(self):
        """Scanning test-openssl-1.0.2g.out"""
        self._binary_test(
            'test-openssl-1.0.2g.out',
            'openssl',
            '1.0.2g',
            [
                # Check for known cves in this version
                "CVE-2016-2107",
                "CVE-2016-2105",
                "CVE-2016-2106",
                "CVE-2016-2109",
                "CVE-2016-2176",
            ],
            [
                # Check to make sure an older CVE isn't included
                "CVE-2016-0800",
            ])
```
* Not sure what CVEs apply to a version? The checkers themselves often have links, and have the vendor/product pair so you can find them in the national vulnerability database as well. [Here's a link to the openssl checker for you to look at](https://github.com/intel/cve-bin-tool/blob/master/cve_bin_tool/checkers/openssl.py) and the rest are in [`cve-bin-tool/checkers/`](https://github.com/intel/cve-bin-tool/tree/master/cve_bin_tool/checkers)
* You'll also need to make a fake file designed to trick the checker into thinking it has found that version of the library.  You can see these files in [`test/binaries/`](https://github.com/intel/cve-bin-tool/tree/master/test/binaries)
* Please note that sometimes the database we're using doesn't have perfect mapping between CVEs and product versions -- if you try to write a test that doesn't work because of that mapping but the description in the CVE says that version should be vulnerable, don't discard it! Instead, please make a note of it in a github issue can investigate and maybe report it upstream.

## Adding new tests: Signature tests against real files

To make the basic test suite run quickly, we use "faked" binary files to test the **CVE mappings**.  However, we want to be able to test real files to test that the **signatures** work on real-world data.

In #99, I've added a _file_test function (to match the existing _binary_test) that takes a url, and package name and a version, and downloads the file, runs the scanner against it, and makes sure it is the file that you've specified.  But we need more tests!

* Existing tests are in [`test/`](https://github.com/intel/cve-bin-tool/tree/master/test)
* You can see the scanner tests in ['tests/test_scanner.py'](https://github.com/intel/cve-bin-tool/blob/master/test/test_scanner.py)
* To add a new test, find an appropriate publicly available file (linux distribution packages and public releases of the packages itself are ideal) 
* Make sure to hide it behind the LONG_TESTS flag so we aren't doing huge number of downloads for every test suite run

```
    @unittest.skipUnless(os.getenv('LONG_TESTS') == '1', 'Skipping long tests')
    def test_rpm_curl_7_32_0(self):
        """
        test to see if we detect a real copy of curl 7.32.0
        """
        self._file_test(
            'https://archives.fedoraproject.org/pub/archive/fedora/linux/releases/20/Everything/x86_64/os/Packages/c/',
            'curl-7.32.0-3.fc20.x86_64.rpm',
            'curl',
            '7.32.0')
```

Ideally, we should have at least one such test for each checker, and it would be nice to have some different sources for each as well. For example, for packages available in common Linux distributions, we might want to have one from fedora, one from debian, and one direct from upstream to show that we detect all those versions.
