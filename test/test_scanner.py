# pylint: disable=too-many-public-methods, too-many-arguments, fixme
"""
CVE-bin-tool tests
"""
import itertools
import os
import shutil
import sys
import tempfile
import unittest
from collections import defaultdict

import pytest

from cve_bin_tool.cvedb import CVEDB
from cve_bin_tool.scanner import Scanner, InvalidFileError
from test.mapping_test_data import mapping_test_data
from test.package_test_data import package_test_data
from test.utils import download_file, LONG_TESTS

BINARIES_PATH = os.path.join(os.path.abspath(os.path.dirname(__file__)), "binaries")


class TestScanner:
    """Runs a series of tests against our "faked" binaries.

    The faked binaries are very small c files containing the same string signatures we use
    in the cve-bin-tool.  They should trigger results as if they contained the library and
    version specified in the file name.

    At this time, the tests work only in python3.
    """

    @classmethod
    def setup_class(cls):
        cls.cvedb = CVEDB()
        if os.getenv("UPDATE_DB") == "1":
            cls.cvedb.get_cvelist_if_stale()
        else:
            print("Skip NVD database updates.")
        # Instantiate a scanner
        cls.scanner = Scanner(cls.cvedb)
        # temp dir for mapping tests
        cls.map_test_dir = tempfile.mkdtemp(prefix="mapping-test-")
        # temp dir for tests that require downloads
        cls.tempdir = tempfile.mkdtemp(prefix="cve-bin-tool-")

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.tempdir)
        shutil.rmtree(cls.map_test_dir)

    def setup_method(self):
        self.cvedb.open()

    def teardown_method(self):
        self.cvedb.close()

    def test_false_positive(self):
        self.scanner.all_cves = defaultdict(dict)
        with tempfile.NamedTemporaryFile(
            "w+b",
            suffix="-test-false-positive.out",
            dir=self.map_test_dir,
            delete=False,
        ) as f:
            common_signatures = [
                # common strings generated by a compiler
                b"\x7f\x45\x4c\x46\x02\x01\x01\x03\n",
                b"GCC: (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0\n",
                b"GNU C17 8.1.0 -mtune=core2 -march=nocona -g -g -g -O2 -O2 -O2 -fno-ident -fbuilding-libgcc -fno-stack-protector\n",
                b"../../../../../src/gcc-8.1.0/libgcc/libgcc2.c\n",
                b"C:\mingw810\x86_64-810-posix-seh-rt_v6-rev0\build\gcc-8.1.0\x86_64-w64-mingw32\libgcc\n",
                b"GLIBC_2.2.5\n",
                b"printf@@GLIBC_2.2.5\n",
                b"__libc_start_main@@GLIBC_2.2.5" b"__cxa_finalize@@GLIBC_2.2.5\n",
                b"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\n",
                # bare version strings.
                b"1_0",
                b"1_2_3",
                b"1.4",
                b"1.2.3",
                b"6.7a",
                b"8.9.10-11",
                b"1-2",
                b"1-2-4",
                b"1.2.3-rc.1"
            ]
            f.writelines(common_signatures)
            filename = f.name
        self.scanner.scan_file(os.path.join(self.map_test_dir, filename))
        assert self.scanner.all_cves == {}

    @pytest.mark.parametrize(
        "module, version, version_strings",
        map(lambda d: d.values(), mapping_test_data),
    )
    def test_version_mapping(self, module, version, version_strings):
        """ Helper function to scan a binary and check that it contains
        certain cves for a version and doesn't contain others."""

        # Run the scan
        self.scanner.all_cves = defaultdict(dict)
        version_strings = list(map(lambda s: f"{s}\n".encode("ascii"), version_strings))
        # first filename will test "is" and second will test "contains"
        filenames = [
            f"-{module}-{version}.out",
            f"{'.'.join(list(module))}-{version}.out",
        ]
        for filename in filenames:
            with tempfile.NamedTemporaryFile(
                "w+b", suffix=filename, dir=self.map_test_dir, delete=False
            ) as f:
                f.write(b"\x7f\x45\x4c\x46\x02\x01\x01\x03\n")
                f.writelines(version_strings)
                filename = f.name
            self.scanner.scan_file(os.path.join(self.map_test_dir, filename))
            # print(d)
            # Make sure the package and version are in the results
            assert module in self.scanner.all_cves
            assert version in self.scanner.all_cves[module]

    @pytest.mark.parametrize("url, package_name, module, version", package_test_data)
    @unittest.skipUnless(LONG_TESTS() > 0, "Skipping long tests")
    def test_version_in_package(self, url, package_name, module, version):
        """ Helper function to get a file (presumed to be a real copy
        of a library, probably from a Linux distribution) and run a
        scan on it.  Any test using this should likely be listed as a
        long test."""
        # get file
        tempfile = os.path.join(self.tempdir, package_name)
        download_file(url + package_name, tempfile)
        # new scanner for the new test.
        self.scanner = Scanner(cvedb=self.cvedb, should_extract=True)
        # run the tests
        self.scanner.recursive_scan(tempfile)

        # make sure we found the expected package/version
        assert module in self.scanner.all_cves
        assert version in self.scanner.all_cves[module]

    def test_does_not_scan_symlinks(self):
        """ Test that the scanner doesn't scan symlinks """
        if sys.platform.startswith("linux"):
            # we can only do this in linux since symlink is privilege operation in windows
            os.symlink("non-existant-file", "non-existant-link")
            try:
                assert self.scanner.scan_file("non-existant-link") is None
            finally:
                os.unlink("non-existant-link")

    def test_cannot_open_file(self):
        """ Test behaviour when file cannot be opened """
        with pytest.raises(InvalidFileError):
            self.scanner.scan_file(os.path.join(self.map_test_dir, "non-existant-file"))
