# Copyright (C) 2021 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import csv
import os
import re
import subprocess
from importlib.metadata import version

REQ_TXT = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "requirements.txt")
)
REQ_CSV = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "requirements.csv")
)
DOC_TXT = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "doc", "requirements.txt")
)
DOC_CSV = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "doc", "requirements.csv")
)

CACHE_PATH = os.path.join(os.path.expanduser("~"), ".cache", "cve-bin-tool")

CACHE_CSV = os.path.join(CACHE_PATH, "requirements.csv")

HTML_DEP_PATH = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        "..",
        "cve_bin_tool",
        "output_engine",
        "html_reports",
        "js",
    )
)
HTML_DEP_CSV = os.path.join(HTML_DEP_PATH, "dependencies.csv")

# Dependencies that currently have CVEs
# Remove from the list once they are updated
ALLOWED_PACKAGES = ["reportlab"]


def get_out_of_sync_packages(csvfile, txtfile):

    out_of_sync_packages = []
    csv_package_names = []

    with open(csvfile, "r") as csvf, open(txtfile, "r") as txt:
        csvfl = csv.reader(csvf)
        next(csvfl)
        for (vendor, product) in csvfl:
            csv_package_names.append(product)
        lines = txt.readlines()
        for line in lines:
            txt_package = re.split(">|\\[|;|=|\n", line)[0]
            if txt_package not in csv_package_names:
                out_of_sync_packages.append(txt_package)

    return out_of_sync_packages


# Test to check if the requirements.csv files are in sync with requirements.txt files
def test_txt_csv_sync():

    out_of_sync_packages = get_out_of_sync_packages(
        REQ_CSV, REQ_TXT
    ) + get_out_of_sync_packages(DOC_CSV, DOC_TXT)

    assert (
        out_of_sync_packages == []
    ), f"The CSV file is out of sync! Please add {', '.join(out_of_sync_packages)} in the respective requirements.csv file"


def get_cache_csv_data(file):

    data = []

    with open(file, "r") as f:
        r = csv.reader(f)
        next(r)
        for (vendor, product) in r:
            if file is HTML_DEP_CSV:
                file_name = f"{HTML_DEP_PATH}/{product}"
                if not file_name.endswith(".js"):
                    file_name += ".js"
                with open(file_name) as f:
                    file_content = f.read()
                    html_dep_version = re.search(
                        r"v([0-9]+\.[0-9]+\.[0-9]+)", file_content
                    ).group(1)
                    if product not in ALLOWED_PACKAGES:
                        data.append((vendor, product, html_dep_version))
            else:
                if "_not_in_db" not in vendor and product not in ALLOWED_PACKAGES:
                    data.append((vendor, product, version(product)))

        return data


# Test to check for CVEs in cve-bin-tool requirements/dependencies
def test_requirements():

    cache_csv_data = (
        get_cache_csv_data(REQ_CSV)
        + get_cache_csv_data(DOC_CSV)
        + get_cache_csv_data(HTML_DEP_CSV)
    )

    if not os.path.exists(CACHE_PATH):
        os.mkdir(CACHE_PATH)

    # writes a cache CSV file
    with open(CACHE_CSV, "w") as f:
        writer = csv.writer(f)
        fieldnames = ["vendor", "product", "version"]
        writer = csv.writer(f)
        writer.writerow(fieldnames)
        for row in cache_csv_data:
            writer.writerow(row)

    cve_check = subprocess.run(
        ["python", "-m", "cve_bin_tool.cli", "--input-file", CACHE_CSV]
    )
    assert (
        cve_check.returncode == 0
    ), f"{cve_check.returncode} dependecies/requirements have CVEs"
