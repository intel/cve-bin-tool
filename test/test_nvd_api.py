# Copyright (C) 2021 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import os
import shutil
import tempfile
from datetime import datetime, timedelta
from test.utils import LONG_TESTS

import pytest
import aiohttp

from cve_bin_tool.cvedb import CVEDB
from cve_bin_tool.data_sources import nvd_source
from cve_bin_tool.nvd_api import (
    NVD_API as _NVD_API,
    FEED as NVD_API_FEED,
    NVD_CVE_STATUS,
)

from .nvd_style import aiohttp_nvd_style_api_endpoint

# The versions we have implemented which we will be testing here.
NVD_API_VERSIONS_IMPLEMENTED = ["1.0", "2.0"]
# Define NVD_API with testing specifics for shorthand instantiation.
NVD_API = lambda *args, **kwargs: _NVD_API(
    *args,
    **{
        **{
            "feed": "/",
            "stats": "/",
            "api_key": os.getenv("nvd_api_key") or "",
        },
        **kwargs,
    },
)


@pytest.fixture
def aiohttp_session(event_loop, aiohttp_client):
    app = aiohttp.web.Application()
    app.router.add_get("/", aiohttp_nvd_style_api_endpoint)
    app.router.add_get("/1.0", aiohttp_nvd_style_api_endpoint)
    app.router.add_get("/2.0", aiohttp_nvd_style_api_endpoint)
    return event_loop.run_until_complete(aiohttp_client(app))


class TestNVD_API:
    @classmethod
    def setup_class(cls):
        cls.outdir = tempfile.mkdtemp(prefix="cvedb-api-")

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.outdir)

    @pytest.mark.asyncio
    @pytest.mark.skipif(
        LONG_TESTS() != 1 or not os.getenv("nvd_api_key"),
        reason="NVD tests run only in long tests",
    )
    @pytest.mark.parametrize("api_version", NVD_API_VERSIONS_IMPLEMENTED)
    async def test_get_nvd_params(self, aiohttp_session, api_version):
        """Test NVD for a future date. It should be empty"""
        nvd_api = NVD_API(
            session=aiohttp_session,
            api_version=api_version,
        )
        await nvd_api.get_nvd_params(
            time_of_last_update=(datetime.now() + timedelta(days=2))
        )
        await nvd_api.get()
        assert nvd_api.total_results == 0 and nvd_api.all_cve_entries == []

    @pytest.mark.asyncio
    @pytest.mark.skipif(
        LONG_TESTS() != 1 or not os.getenv("nvd_api_key"),
        reason="NVD tests run only in long tests",
    )
    @pytest.mark.parametrize("api_version", NVD_API_VERSIONS_IMPLEMENTED)
    async def test_total_results_count(self, aiohttp_session, api_version):
        """Total results should be greater than or equal to the current fetched cves"""
        nvd_api = NVD_API(
            session=aiohttp_session,
            api_version=api_version,
        )
        await nvd_api.get_nvd_params(
            time_of_last_update=datetime.now() - timedelta(days=2)
        )
        await nvd_api.get()
        assert len(nvd_api.all_cve_entries) >= nvd_api.total_results

    @pytest.mark.asyncio
    @pytest.mark.skipif(
        LONG_TESTS() != 1 or not os.getenv("nvd_api_key"),
        reason="NVD tests run only in long tests",
    )
    @pytest.mark.parametrize("api_version", NVD_API_VERSIONS_IMPLEMENTED)
    async def test_nvd_incremental_update(self, aiohttp_session, api_version):
        """Test to check whether we are able to fetch and save the nvd entries using time_of_last_update"""
        nvd_api = NVD_API(
            incremental_update=True,
            session=aiohttp_session,
            api_version=api_version,
        )
        await nvd_api.get_nvd_params(
            time_of_last_update=datetime.now() - timedelta(days=4)
        )
        await nvd_api.get()
        source_nvd = nvd_source.NVD_Source()
        cvedb = CVEDB(cachedir=self.outdir)
        if api_version == "1.0":
            cvedb.data = [(source_nvd.format_data(nvd_api.all_cve_entries), "NVD")]
        elif api_version == "2.0":
            cvedb.data = [(source_nvd.format_data_api2(nvd_api.all_cve_entries), "NVD")]
        else:
            raise NotImplementedError(f"Unknown NVD API version {api_version}")
        cvedb.init_database()
        cvedb.populate_db()
        cvedb.check_cve_entries()
        assert cvedb.cve_count == nvd_api.total_results

    @pytest.mark.asyncio
    @pytest.mark.skipif(
        LONG_TESTS() != 1 or not os.getenv("nvd_api_key"),
        reason="NVD tests run only in long tests",
    )
    @pytest.mark.parametrize("api_version", NVD_API_VERSIONS_IMPLEMENTED)
    async def test_empty_nvd_result(self, aiohttp_session, api_version):
        """Test to check nvd results non-empty result. Total result should be greater than 0"""
        nvd_api = NVD_API(
            session=aiohttp_session,
            api_version=api_version,
        )
        await nvd_api.get_nvd_params()
        assert nvd_api.total_results > 0

    @pytest.mark.asyncio
    @pytest.mark.skip(reason="NVD does not return the Received count")
    @pytest.mark.parametrize("api_version", NVD_API_VERSIONS_IMPLEMENTED)
    async def test_api_cve_count(self, aiohttp_session, api_version):
        """Test to match the totalResults and the total CVE count on NVD"""

        nvd_api = NVD_API(
            session=aiohttp_session,
            api_version=api_version,
        )
        await nvd_api.get_nvd_params()
        await nvd_api.load_nvd_request(0)
        cve_count = await nvd_api.nvd_count_metadata(nvd_api.session, nvd_api.stats)

        # Difference between the total and rejected CVE count on NVD should be equal to the total CVE count
        # Received CVE count might be zero
        assert (
            abs(nvd_api.total_results - (cve_count["Total"] - cve_count["Rejected"]))
            <= cve_count["Received"]
        )
